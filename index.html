<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>P1AIN0&#39;S BLOG</title>
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="P1AIN0&#39;S BLOG"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="P1AIN0&#39;S BLOG" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  




<meta name="generator" content="Hexo 5.4.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">P1AIN0&#39;S BLOG</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header logo">
  <h1>P1AIN0&#39;S BLOG<span class="blink-fast">|</span></h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">

</div>    

		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2023/02/14/CPU乱序执行/" >CPU乱序执行</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2023-02-14  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2023/02/14/CPU乱序执行/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<p>先看一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">atomic_int</span> flag;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAG atomic_load(&amp;flag)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAG_XOR(val) atomic_fetch_xor(&amp;flag, val)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WAIT_FOR(cond) while (!(cond)) ;</span></span><br><span class="line"></span><br><span class="line"> __attribute__((noinline))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_read_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x=<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// __sync_synchronize();</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> __attribute__((noinline))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_y_read_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  y=<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// __sync_synchronize();</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T1</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    WAIT_FOR((FLAG &amp; <span class="number">1</span>));</span><br><span class="line">    write_x_read_y();</span><br><span class="line">    FLAG_XOR(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    WAIT_FOR((FLAG &amp; <span class="number">2</span>));</span><br><span class="line">    write_y_read_x();</span><br><span class="line">    FLAG_XOR(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    x = y = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//__sync_synchronize(); // full barrier</span></span><br><span class="line">    <span class="comment">//usleep(1);            // + delay</span></span><br><span class="line">    <span class="comment">// assert(FLAG == 0);</span></span><br><span class="line">    FLAG_XOR(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// T1 and T2 clear 0/1-bit, respectively</span></span><br><span class="line">    WAIT_FOR(FLAG == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> tid1;</span><br><span class="line">  <span class="keyword">pthread_t</span> tid2;</span><br><span class="line">  <span class="keyword">pthread_t</span> tid3;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  <span class="keyword">void</span> *ptr = &amp;ret;</span><br><span class="line">  ret = pthread_create(&amp;tid1, <span class="literal">NULL</span>, T1, ptr);</span><br><span class="line"></span><br><span class="line">  ret = pthread_create(&amp;tid2, <span class="literal">NULL</span>, T2, ptr);</span><br><span class="line"></span><br><span class="line">  ret = pthread_create(&amp;tid3, <span class="literal">NULL</span>, Tsync, ptr);</span><br><span class="line"></span><br><span class="line">  pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">  pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">  pthread_join(tid3, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码创建了三个线程，T1， T2，Tsync。<br>Tsync的作用是协同T1和T2线程的，先将x，y重新初始化为0，再把T1和T2继续执行的条件FLAG复位，等T1和T2都打印完一遍后，输出换行符。<br>T1先将x赋值为1，再打印y的值。<br>T2先将y赋值为1，再打印x的值。<br>理论上打印的结果不可能出现 0 0 的情况。但是试验结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gcc mem-ordering.c -o test</span><br><span class="line">./test | head -n 1000000 | sort | uniq -c</span><br><span class="line"></span><br><span class="line">987382 0 0 </span><br><span class="line">10216 0 1 </span><br><span class="line">2396 1 0 </span><br><span class="line">   6 1 1 </span><br></pre></td></tr></table></figure>

<p>这证明CPU确实实在乱序执行的。<br>但是如果将<code>__sync_synchronize();</code>这两行注释打开。结果就不一样了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">366378 0 1 </span><br><span class="line">30491 1 0 </span><br><span class="line">603128 1 1 </span><br></pre></td></tr></table></figure>

<p>这次阻止了乱序执行。打开反汇编代码一窥究竟，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">0000000100003c90 &lt;_write_x_read_y&gt;:</span><br><span class="line">100003c90: 55                           pushq   %rbp</span><br><span class="line">100003c91: 48 89 e5                     movq    %rsp, %rbp</span><br><span class="line">100003c94: 48 83 ec 10                  subq    $16, %rsp</span><br><span class="line">100003c98: 48 8d 05 65 43 00 00         leaq    17253(%rip), %rax       ## 0x100008004 &lt;_x&gt;</span><br><span class="line">100003c9f: c7 00 01 00 00 00            movl    $1, (%rax)</span><br><span class="line">100003ca5: 0f ae f0                     mfence</span><br><span class="line">100003ca8: 48 8d 05 59 43 00 00         leaq    17241(%rip), %rax       ## 0x100008008 &lt;_y&gt;</span><br><span class="line">100003caf: 8b 30                        movl    (%rax), %esi</span><br><span class="line">100003cb1: 48 8d 3d f4 02 00 00         leaq    756(%rip), %rdi         ## 0x100003fac &lt;_pthread_join+0x100003fac&gt;</span><br><span class="line">100003cb8: b0 00                        movb    $0, %al</span><br><span class="line">100003cba: e8 db 02 00 00               callq   0x100003f9a &lt;_pthread_join+0x100003f9a&gt;</span><br><span class="line">100003cbf: 48 83 c4 10                  addq    $16, %rsp</span><br><span class="line">100003cc3: 5d                           popq    %rbp</span><br><span class="line">100003cc4: c3                           retq</span><br><span class="line">100003cc5: 66 2e 0f 1f 84 00 00 00 00 00        nopw    %cs:(%rax,%rax)</span><br><span class="line">100003ccf: 90                           nop</span><br><span class="line"></span><br><span class="line">0000000100003cd0 &lt;_write_y_read_x&gt;:</span><br><span class="line">100003cd0: 55                           pushq   %rbp</span><br><span class="line">100003cd1: 48 89 e5                     movq    %rsp, %rbp</span><br><span class="line">100003cd4: 48 83 ec 10                  subq    $16, %rsp</span><br><span class="line">100003cd8: 48 8d 05 29 43 00 00         leaq    17193(%rip), %rax       ## 0x100008008 &lt;_y&gt;</span><br><span class="line">100003cdf: c7 00 01 00 00 00            movl    $1, (%rax)</span><br><span class="line">100003ce5: 0f ae f0                     mfence</span><br><span class="line">100003ce8: 48 8d 05 15 43 00 00         leaq    17173(%rip), %rax       ## 0x100008004 &lt;_x&gt;</span><br><span class="line">100003cef: 8b 30                        movl    (%rax), %esi</span><br><span class="line">100003cf1: 48 8d 3d b4 02 00 00         leaq    692(%rip), %rdi         ## 0x100003fac &lt;_pthread_join+0x100003fac&gt;</span><br><span class="line">100003cf8: b0 00                        movb    $0, %al</span><br><span class="line">100003cfa: e8 9b 02 00 00               callq   0x100003f9a &lt;_pthread_join+0x100003f9a&gt;</span><br><span class="line">100003cff: 48 83 c4 10                  addq    $16, %rsp</span><br><span class="line">100003d03: 5d                           popq    %rbp</span><br><span class="line">100003d04: c3                           retq</span><br><span class="line">100003d05: 66 2e 0f 1f 84 00 00 00 00 00        nopw    %cs:(%rax,%rax)</span><br><span class="line">100003d0f: 90                           nop</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>原来 <code>__sync_synchronize()</code> 函数在中间添加了<code>mfence</code>指令起到内存屏障的作用。<br>假设现在写x读y。正常情况下当cpu写x的时候，发现不在缓存里，而下一条读指令的y恰好在缓存里，然后他就想：“反正这俩有没有关系，我就先读y了，先让x加载着缓存，等我读完y了再写x一样，还更快”。但是加了mfence就不一样了，mfence相当于告诉cpu你不准这么干，前边的那条指令的操作数不在缓存里，你就给我等着。必须把前边干完了，再干下一条。</p>

	
	</div>
  <a type="button" href="/2023/02/14/CPU乱序执行/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/11/13/unicorn分析/" >unicorn分析</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-11-13  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/11/13/unicorn分析/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="unicorn简介"><a href="#unicorn简介" class="headerlink" title="unicorn简介"></a>unicorn简介</h2><p>unicorn是一个轻量级，多平台，多架构的CPU模拟器框架，支持多种CPU架构，支持windows和linux，提供的API接口简洁易用。使用JIT编译技术，性能表现优异。unicorn是基于qemu而开发的，裁剪了qemu的CPU模拟部分。qemu的TCG机制保证了unicorn具有跨平台优点。</p>
<h2 id="unicorn-API"><a href="#unicorn-API" class="headerlink" title="unicorn API"></a>unicorn API</h2><h3 id="内存映射-反映射"><a href="#内存映射-反映射" class="headerlink" title="内存映射/反映射"></a>内存映射/反映射</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_mem_map</span><span class="params">(uc_engine* uc, <span class="keyword">uint64_t</span> address, <span class="keyword">size_t</span> size, <span class="keyword">uint32_t</span> perms)</span></span>;</span><br><span class="line"><span class="function">uc_err <span class="title">uc_mem_unmap</span><span class="params">(uc_engine* uc, <span class="keyword">uint64_t</span> address, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="内存读写"><a href="#内存读写" class="headerlink" title="内存读写"></a>内存读写</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_mem_read</span><span class="params">(uc_engine* uc, <span class="keyword">uint64_t</span> address, <span class="keyword">void</span>* bytes, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function">uc_err <span class="title">uc_mem_write</span><span class="params">(uc_engine* uc, <span class="keyword">uint64_t</span> address, <span class="keyword">const</span> <span class="keyword">void</span>* bytes, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="寄存器读写"><a href="#寄存器读写" class="headerlink" title="寄存器读写"></a>寄存器读写</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_reg_read</span><span class="params">(un_engine* uc, <span class="keyword">int</span> regid, <span class="keyword">void</span>* value)</span></span>;</span><br><span class="line"><span class="function">uc_err <span class="title">uc_reg_write</span><span class="params">(un_engine* uc, <span class="keyword">int</span> regid, <span class="keyword">const</span> <span class="keyword">void</span>* value)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="指令回调"><a href="#指令回调" class="headerlink" title="指令回调"></a>指令回调</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_hook_add</span><span class="params">(uc_engine *uc, uc_hook *hh, <span class="keyword">int</span> type, <span class="keyword">void</span> *callback, <span class="keyword">void</span> *user_data, <span class="keyword">uint64_t</span> begin, <span class="keyword">uint64_t</span> end, ...)</span></span>;</span><br><span class="line"><span class="function">uc_err <span class="title">uc_hook_del</span><span class="params">(uc_engine *uc, uc_hook hh)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="打开启动停止"><a href="#打开启动停止" class="headerlink" title="打开启动停止"></a>打开启动停止</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uc_err <span class="title">uc_open</span><span class="params">(uc_arch arch, uc_mode mode, uc_engine **uc)</span></span>;</span><br><span class="line"><span class="function">uc_err <span class="title">uc_emu_start</span><span class="params">(uc_engine *uc, <span class="keyword">uint64_t</span> begin, <span class="keyword">uint64_t</span> until, <span class="keyword">uint64_t</span> timeout, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function">uc_err <span class="title">uc_emu_stop</span><span class="params">(uc_engine *uc)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="unicorn使用流程"><a href="#unicorn使用流程" class="headerlink" title="unicorn使用流程"></a>unicorn使用流程</h2><p>初始化unicorn接口 -&gt; 初始化平台信息 -&gt; 映射虚拟机物理内存 -&gt; 设置虚拟机寄存器组 -&gt; 设置相应的指令回调函数（HOOK_CODE每条指令 HOOK_BLOCK每个指令块 HOOK_INTR int n和syscall执行时回调 HOOK_INSN 特定指令执行时回调） -&gt; 开始模拟执行</p>

	
	</div>
  <a type="button" href="/2021/11/13/unicorn分析/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/09/30/一个加密木马的分析/" >一个加密木马的分析</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-09-30  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/09/30/一个加密木马的分析/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>主要分析木马的解密过程。</p>
<h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>使用ollydbg利用命令<code>bp VirtualAlloc</code>首先在VirtualAlloc处下断点，第一次是个size=0xE0，暂时忽略，第二次size=0xDCA00，看起来像是一个pe文件的大小了，调用地址也比较奇怪，是栈空间的地址，有此可以断定在此之前一定还有另一个解密过程，把代码揭秘到栈空间去执行。</p>
<p>先去看它第一次的解密过程，把它返回地址(0x12f88f)和数据(0x85)记下来，重新运行该样本，等它断在入口点时，在这个栈地址上下硬件断点，等这地方的数据成为0x85时再观察，来到了0x67DF8F地址处，如图所示：</p>
<p><img src="1.png"></p>
<p>接下来就是分析这片的代码干了什么事，经过分析后，我添加了注释，如下图所示：</p>
<p><img src="2.png"></p>
<p>其实就是简单的解密操作，源数据地址在0x46B370，大小为0x67D，解密密钥地址为0x53FA20,大小为0x10字节，目标地址为0x12F714。</p>
<p>接下来分析第二个解密的地方，首先在分配完内存后，使用硬件断点找到解密代码的地方，在0x12f9d3地址处把数据复制进目标地址，然后在0x12fa25地址处解密，先分析复制数据区域的代码，如图所示：</p>
<p><img src="3.png"></p>
<pre><code>0012F66C   004020B1
0012F670   004D6A10
0012F674   00540A40
0012F678   005AAB40
0012F67C   00614BE0
0012F680   006E9330
0012F684   0067F000
0012F688   0046CA00
</code></pre>
<p>经过分析复制的过程是这样的：将这八个地址的数据，每次循环各取出一字节，按顺序复制到目标缓冲区中。</p>
<p>接下来分析解密过程：</p>
<p><img src="4.png"></p>
<p>解密也是使用的0x53FA20地址处的密钥，密钥与数据xor运算后，又使用了数据的索引的低16位进行了一次xor运算得到揭秘结果，通过，通过MZ和PE的标志，由此我们推断这是个PE文件。</p>
<p>加载该PE文件的方式使用内存加载：为了描述清楚具体的加载方式我写了一个效果一样的加载器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELOC_32BIT_FIELD 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELOC_64BIT_FIELD 0xA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELOC_FIELD RELOC_64BIT_FIELD</span></span><br><span class="line"><span class="keyword">typedef</span> ULONG_PTR FIELD_PTR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELOC_FIELD RELOC_32BIT_FIELD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">BASE_RELOCATION_ENTRY</span> &#123;</span></span><br><span class="line">    WORD Offset : <span class="number">12</span>;</span><br><span class="line">    WORD Type : <span class="number">4</span>;</span><br><span class="line">&#125; BASE_RELOCATION_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">repair_reloc</span><span class="params">(PIMAGE_NT_HEADERS nt, BYTE* image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BYTE* new_image_base = image;</span><br><span class="line">    IMAGE_DATA_DIRECTORY reloc_dict = nt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];</span><br><span class="line">    <span class="keyword">if</span> (reloc_dict.VirtualAddress == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    PIMAGE_BASE_RELOCATION reloc = (PIMAGE_BASE_RELOCATION)(reloc_dict.VirtualAddress + image);</span><br><span class="line">    <span class="keyword">while</span> (reloc-&gt;VirtualAddress != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DWORD page = reloc-&gt;VirtualAddress;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Page: %d\n&quot;</span>, page);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (reloc-&gt;SizeOfBlock &gt;= <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> count = (reloc-&gt;SizeOfBlock - <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="keyword">sizeof</span>(WORD);</span><br><span class="line">            BASE_RELOCATION_ENTRY* <span class="built_in">list</span> = (BASE_RELOCATION_ENTRY*)(LPWORD)(reloc + <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Count:%d\n&quot;</span>, count);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">list</span>[i].Type &amp; RELOC_FIELD)</span><br><span class="line">                &#123;</span><br><span class="line">                    DWORD rva = <span class="built_in">list</span>[i].Offset + page;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;RVA : %x\n&quot;</span>,rva);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                    PULONG_PTR p = (PULONG_PTR)((LPBYTE)image + rva);</span><br><span class="line">                    *p = ((*p) - nt-&gt;OptionalHeader.ImageBase) + new_image_base;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reloc = (PIMAGE_BASE_RELOCATION)((LPBYTE)reloc + reloc-&gt;SizeOfBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">repair_imports</span><span class="params">(PIMAGE_NT_HEADERS nt, BYTE* image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMAGE_DATA_DIRECTORY imp_dict = nt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];</span><br><span class="line">    <span class="keyword">if</span> (imp_dict.VirtualAddress == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR imp_desc = (PIMAGE_IMPORT_DESCRIPTOR)(imp_dict.VirtualAddress + image);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (imp_desc-&gt;Name != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LPCSTR library_name = (LPCSTR)(imp_desc-&gt;Name + image);</span><br><span class="line">        HMODULE library = LoadLibraryA(library_name);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Loading: %s \n&quot;</span>, library_name);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (library)</span><br><span class="line">        &#123;</span><br><span class="line">            PIMAGE_THUNK_DATA thunk = <span class="literal">NULL</span>;</span><br><span class="line">            thunk = (PIMAGE_THUNK_DATA)(image + imp_desc-&gt;FirstThunk);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (thunk-&gt;u1.AddressOfData != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">void</span>* functionAddress = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">if</span> (IMAGE_SNAP_BY_ORDINAL(thunk-&gt;u1.Ordinal))</span><br><span class="line">                &#123;</span><br><span class="line">                    LPCSTR functionOrdinal = (LPCSTR)IMAGE_ORDINAL(thunk-&gt;u1.Ordinal);</span><br><span class="line">                    functionAddress = GetProcAddress(library, functionOrdinal);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    PIMAGE_IMPORT_BY_NAME functionName = (PIMAGE_IMPORT_BY_NAME)(image + thunk-&gt;u1.AddressOfData);</span><br><span class="line">                    functionAddress = GetProcAddress(library, functionName-&gt;Name);</span><br><span class="line">                &#125;</span><br><span class="line">                thunk-&gt;u1.Function = functionAddress;</span><br><span class="line">                ++thunk;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        imp_desc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">load_pe</span><span class="params">(BYTE* raw, <span class="keyword">int</span> size, <span class="keyword">void</span>** image_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER dos_header = (PIMAGE_DOS_HEADER)raw;</span><br><span class="line">    PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)(raw + dos_header-&gt;e_lfanew);</span><br><span class="line">    BYTE * image = (BYTE*)VirtualAlloc(<span class="literal">NULL</span>, nt-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (image == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;VirtualAlloc failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Image Alloc at %p&quot;</span>, image);</span><br><span class="line">    <span class="built_in">memcpy</span>(image, raw, nt-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map sections</span></span><br><span class="line">    PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(nt);</span><br><span class="line">    <span class="keyword">for</span> (WORD i = <span class="number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>((BYTE*)(image)+section[i].VirtualAddress, (BYTE*)(raw)+section[i].PointerToRawData, section[i].SizeOfRawData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//reloc</span></span><br><span class="line">    BOOL state = repair_reloc(nt, image);</span><br><span class="line">    <span class="keyword">if</span> (!state)</span><br><span class="line">    &#123;</span><br><span class="line">        VirtualFree(image, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//import</span></span><br><span class="line">    state = repair_imports(nt, image);</span><br><span class="line">    <span class="keyword">if</span> (!state)</span><br><span class="line">    &#123;</span><br><span class="line">        VirtualFree(image, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *image_ = image;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BYTE* <span class="title">read_exe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* exe_path, <span class="keyword">int</span>* size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE file_handle = CreateFileA(exe_path, GENERIC_READ, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file_handle || file_handle == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open file failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *size = GetFileSize(file_handle, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (*size == INVALID_FILE_SIZE) &#123;</span><br><span class="line">        CloseHandle(file_handle);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//read the file</span></span><br><span class="line">    BYTE* raw = VirtualAlloc(<span class="literal">NULL</span>, *size, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (raw == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ReadFile(file_handle, raw, *size, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[ERROR] Reading the file has failed!\n&quot;</span>);</span><br><span class="line">        VirtualFree(raw, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        raw = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(file_handle);</span><br><span class="line">    <span class="keyword">return</span> raw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">run_exe</span><span class="params">(BYTE* raw, BYTE* image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER dos_header = (PIMAGE_DOS_HEADER)raw;</span><br><span class="line">    PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)(raw + dos_header-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* entry_point = nt-&gt;OptionalHeader.AddressOfEntryPoint + image;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;Entry Address: %p\n&quot;</span>, entry_point);</span><br><span class="line">    <span class="keyword">int</span> (*exe_entry)() = (<span class="keyword">int</span>(*)())entry_point;</span><br><span class="line">    </span><br><span class="line">    exe_entry();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pe_load &lt;exe_path&gt;\t&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN64</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;64 bit version\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;32 bit version\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* exe_path = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    BYTE* raw = read_exe(exe_path, &amp;size);</span><br><span class="line">    <span class="keyword">if</span> (raw == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span>* image = <span class="literal">NULL</span>;</span><br><span class="line">    BOOL state = load_pe(raw, size, &amp;image);</span><br><span class="line">    <span class="keyword">if</span> (!state)</span><br><span class="line">    &#123;</span><br><span class="line">        VirtualFree(raw, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    state = run_exe(raw, image);</span><br><span class="line"></span><br><span class="line">    VirtualFree(raw, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    VirtualFree(image, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
	
	</div>
  <a type="button" href="/2021/09/30/一个加密木马的分析/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/09/24/Windows系统调用/" >Windows系统调用</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-09-24  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/09/24/Windows系统调用/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="逆向分析目标"><a href="#逆向分析目标" class="headerlink" title="逆向分析目标"></a>逆向分析目标</h2><p>主要分析windows系统调用问题的下列四个问题：</p>
<pre><code>(1)程序进入0环后，原来3环的寄存器会保存到什么地方？
(2)如何根据系统服务号找到要执行的内核函数？
(3)调用时参数是如何传递给内核函数的？
(4)如何返回3环？
</code></pre>
<h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><h3 id="应用层过程分析"><a href="#应用层过程分析" class="headerlink" title="应用层过程分析"></a>应用层过程分析</h3><p>首先在ntdll中找到一个目标函数。我这找的是<code>ZwProtectVirtualMemory</code>。函数详情如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.text:7C92D6D0 ; __stdcall ZwProtectVirtualMemory(x, x, x, x, x)</span><br><span class="line">.text:7C92D6D0                 public _ZwProtectVirtualMemory@20</span><br><span class="line">.text:7C92D6D0 _ZwProtectVirtualMemory@20 proc near    ; CODE XREF: LdrpSnapIAT(x,x,x,x)+64↓p</span><br><span class="line">.text:7C92D6D0                                         ; LdrpSnapIAT(x,x,x,x)+101↓p ...</span><br><span class="line">.text:7C92D6D0                 mov     eax, 89h ; &#x27;‰&#x27;  ; NtProtectVirtualMemory</span><br><span class="line">.text:7C92D6D5                 mov     edx, 7FFE0300h</span><br><span class="line">.text:7C92D6DA                 call    dword ptr [edx]</span><br><span class="line">.text:7C92D6DC                 retn    14h</span><br><span class="line">.text:7C92D6DC _ZwProtectVirtualMemory@20 endp</span><br></pre></td></tr></table></figure>

<p>Windbg中信息如下，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kd&gt; u ntdll!ZwProtectVirtualMemory</span><br><span class="line">ntdll!ZwProtectVirtualMemory:</span><br><span class="line">7c92d6d0 b889000000      mov     eax,89h</span><br><span class="line">7c92d6d5 ba0003fe7f      mov     edx,offset SharedUserData!SystemCallStub (7ffe0300)</span><br><span class="line">7c92d6da ff12            call    dword ptr [edx]</span><br><span class="line">7c92d6dc c21400          ret     14h</span><br><span class="line">7c92d6df 90              nop</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数就干了两件事情，将<strong>89h</strong>调用号存入<strong>eax</strong>寄存器中，调用7FFE0300h地址存的函数的地址。这个地址就是user层进入kernel层的关键，在详细说明这个地址之前我们要先介绍一个结构体<code>_KUSER_SHARED_DATA</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kd&gt; dt _KUSER_SHARED_DATA 7ffe0000</span><br><span class="line">ntdll!_KUSER_SHARED_DATA</span><br><span class="line">   +0x000 TickCountLow     : 0x36237</span><br><span class="line">   +0x004 TickCountMultiplier : 0xfa00000</span><br><span class="line">   +0x008 InterruptTime    : _KSYSTEM_TIME</span><br><span class="line">   +0x014 SystemTime       : _KSYSTEM_TIME</span><br><span class="line">   +0x020 TimeZoneBias     : _KSYSTEM_TIME</span><br><span class="line">   +0x02c ImageNumberLow   : 0x14c</span><br><span class="line">   +0x02e ImageNumberHigh  : 0x14c</span><br><span class="line">   +0x030 NtSystemRoot     : [260] 0x43</span><br><span class="line">   +0x238 MaxStackTraceDepth : 0</span><br><span class="line">   +0x23c CryptoExponent   : 0</span><br><span class="line">   +0x240 TimeZoneId       : 0</span><br><span class="line">   +0x244 Reserved2        : [8] 0</span><br><span class="line">   +0x264 NtProductType    : 1 ( NtProductWinNt )</span><br><span class="line">   +0x268 ProductTypeIsValid : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x26c NtMajorVersion   : 5</span><br><span class="line">   +0x270 NtMinorVersion   : 1</span><br><span class="line">   +0x274 ProcessorFeatures : [64]  &quot;&quot;</span><br><span class="line">   +0x2b4 Reserved1        : 0x7ffeffff</span><br><span class="line">   +0x2b8 Reserved3        : 0x80000000</span><br><span class="line">   +0x2bc TimeSlip         : 0</span><br><span class="line">   +0x2c0 AlternativeArchitecture : 0 ( StandardDesign )</span><br><span class="line">   +0x2c8 SystemExpirationDate : _LARGE_INTEGER 0x0</span><br><span class="line">   +0x2d0 SuiteMask        : 0x110</span><br><span class="line">   +0x2d4 KdDebuggerEnabled : 0x3 &#x27;&#x27;</span><br><span class="line">   +0x2d5 NXSupportPolicy  : 0x2 &#x27;&#x27;</span><br><span class="line">   +0x2d8 ActiveConsoleId  : 0</span><br><span class="line">   +0x2dc DismountCount    : 0</span><br><span class="line">   +0x2e0 ComPlusPackage   : 0xffffffff</span><br><span class="line">   +0x2e4 LastSystemRITEventTickCount : 0x348ba9</span><br><span class="line">   +0x2e8 NumberOfPhysicalPages : 0x1ff6c</span><br><span class="line">   +0x2ec SafeBootMode     : 0 &#x27;&#x27;</span><br><span class="line">   +0x2f0 TraceLogging     : 0</span><br><span class="line">   +0x2f8 TestRetInstruction : 0xc3</span><br><span class="line">   +0x300 SystemCall       : 0x7c92e4f0</span><br><span class="line">   +0x304 SystemCallReturn : 0x7c92e4f4</span><br><span class="line">   +0x308 SystemCallPad    : [3] 0</span><br><span class="line">   +0x320 TickCount        : _KSYSTEM_TIME</span><br><span class="line">   +0x320 TickCountQuad    : 0</span><br><span class="line">   +0x330 Cookie           : 0x55a2fab8</span><br></pre></td></tr></table></figure>

<p>在 User 层和 Kernel 层分别定义了一个 _KUSER_SHARED_DATA 结构区域，用于 User 层和 Kernel 层共享某些数据<br>它们使用固定的地址值映射，_KUSER_SHARED_DATA 结构区域在 User 和 Kernel 层地址分别为：<br>User 层地址为：0x7ffe0000<br>Kernnel 层地址为：0xffdf0000<br>通过winbdg查看，可以发现user层地址0x7ffe0000 和kernel层地址0xffdf0000的内容是一样的，虽然指向的是同一个物理页，但在User 层是只读的，在Kernnel层是可写的。</p>
<p>如果cpu支持快速调用，7FFE0300h地址处保存的函数地址是ntdll.dll!KiFastSystemCall()。如果cpu不支持快速调用，那么保存的函数地址是ntdll.dll!KiIntSystemCall()。</p>
<p>如果你的系统不支持快速调用，那么可以使用<code>!idt -a</code>找到0x2E中断描述符的调用地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kd&gt; !idt -a</span><br><span class="line"></span><br><span class="line">Dumping IDT: 8003f400</span><br><span class="line">...</span><br><span class="line">2e:	8053e481 nt!KiSystemService</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果你的系统支持快速调用，可以通过查询msr寄存器的方式获取进内核的入口函数地址。如下所示：<code>0x8053e540</code>便是我们要查询到的函数（nt!KiFastCallEntry）<br>地址了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kd&gt; rdmsr 174 </span><br><span class="line">msr[174] = 00000000`00000008 ;cs</span><br><span class="line">kd&gt; rdmsr 175</span><br><span class="line">msr[175] = 00000000`f8ac2000 ;esp</span><br><span class="line">kd&gt; rdmsr 176</span><br><span class="line">msr[176] = 00000000`8053e540 ;eip</span><br></pre></td></tr></table></figure>

<h3 id="内核层调用分析"><a href="#内核层调用分析" class="headerlink" title="内核层调用分析"></a>内核层调用分析</h3><p>在分析内核层的调用过程前，我们需要看几个结构体，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kd&gt; dt _KTrap_Frame</span><br><span class="line">nt!_KTRAP_FRAME</span><br><span class="line">   +0x000 DbgEbp           : Uint4B</span><br><span class="line">   +0x004 DbgEip           : Uint4B</span><br><span class="line">   +0x008 DbgArgMark       : Uint4B</span><br><span class="line">   +0x00c DbgArgPointer    : Uint4B</span><br><span class="line">   +0x010 TempSegCs        : Uint4B</span><br><span class="line">   +0x014 TempEsp          : Uint4B</span><br><span class="line">   +0x018 Dr0              : Uint4B</span><br><span class="line">   +0x01c Dr1              : Uint4B</span><br><span class="line">   +0x020 Dr2              : Uint4B</span><br><span class="line">   +0x024 Dr3              : Uint4B</span><br><span class="line">   +0x028 Dr6              : Uint4B</span><br><span class="line">   +0x02c Dr7              : Uint4B</span><br><span class="line">   +0x030 SegGs            : Uint4B</span><br><span class="line">   +0x034 SegEs            : Uint4B</span><br><span class="line">   +0x038 SegDs            : Uint4B</span><br><span class="line">   +0x03c Edx              : Uint4B</span><br><span class="line">   +0x040 Ecx              : Uint4B</span><br><span class="line">   +0x044 Eax              : Uint4B</span><br><span class="line">   +0x048 PreviousPreviousMode : Uint4B</span><br><span class="line">   +0x04c ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x050 SegFs            : Uint4B</span><br><span class="line">   +0x054 Edi              : Uint4B</span><br><span class="line">   +0x058 Esi              : Uint4B</span><br><span class="line">   +0x05c Ebx              : Uint4B</span><br><span class="line">   +0x060 Ebp              : Uint4B</span><br><span class="line">   +0x064 ErrCode          : Uint4B</span><br><span class="line">   +0x068 Eip              : Uint4B</span><br><span class="line">   +0x06c SegCs            : Uint4B</span><br><span class="line">   +0x070 EFlags           : Uint4B</span><br><span class="line">   +0x074 HardwareEsp      : Uint4B</span><br><span class="line">   +0x078 HardwareSegSs    : Uint4B</span><br><span class="line">   +0x07c V86Es            : Uint4B</span><br><span class="line">   +0x080 V86Ds            : Uint4B</span><br><span class="line">   +0x084 V86Fs            : Uint4B</span><br><span class="line">   +0x088 V86Gs            : Uint4B</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kd&gt; dt _KPCR</span><br><span class="line">nt!_KPCR</span><br><span class="line">   +0x000 NtTib            : _NT_TIB</span><br><span class="line">   +0x01c SelfPcr          : Ptr32 _KPCR</span><br><span class="line">   +0x020 Prcb             : Ptr32 _KPRCB</span><br><span class="line">   +0x024 Irql             : UChar</span><br><span class="line">   +0x028 IRR              : Uint4B</span><br><span class="line">   +0x02c IrrActive        : Uint4B</span><br><span class="line">   +0x030 IDR              : Uint4B</span><br><span class="line">   +0x034 KdVersionBlock   : Ptr32 Void</span><br><span class="line">   +0x038 IDT              : Ptr32 _KIDTENTRY</span><br><span class="line">   +0x03c GDT              : Ptr32 _KGDTENTRY</span><br><span class="line">   +0x040 TSS              : Ptr32 _KTSS</span><br><span class="line">   +0x044 MajorVersion     : Uint2B</span><br><span class="line">   +0x046 MinorVersion     : Uint2B</span><br><span class="line">   +0x048 SetMember        : Uint4B</span><br><span class="line">   +0x04c StallScaleFactor : Uint4B</span><br><span class="line">   +0x050 DebugActive      : UChar</span><br><span class="line">   +0x051 Number           : UChar</span><br><span class="line">   +0x052 Spare0           : UChar</span><br><span class="line">   +0x053 SecondLevelCacheAssociativity : UChar</span><br><span class="line">   +0x054 VdmAlert         : Uint4B</span><br><span class="line">   +0x058 KernelReserved   : [14] Uint4B</span><br><span class="line">   +0x090 SecondLevelCacheSize : Uint4B</span><br><span class="line">   +0x094 HalReserved      : [16] Uint4B</span><br><span class="line">   +0x0d4 InterruptMode    : Uint4B</span><br><span class="line">   +0x0d8 Spare1           : UChar</span><br><span class="line">   +0x0dc KernelReserved2  : [17] Uint4B</span><br><span class="line">   +0x120 PrcbData         : _KPRCB</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kd&gt; dt _ETHREAD</span><br><span class="line">nt!_ETHREAD</span><br><span class="line">   +0x000 Tcb              : _KTHREAD</span><br><span class="line">   +0x1c0 CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +0x1c0 NestedFaultCount : Pos 0, 2 Bits</span><br><span class="line">   +0x1c0 ApcNeeded        : Pos 2, 1 Bit</span><br><span class="line">   +0x1c8 ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +0x1c8 LpcReplyChain    : _LIST_ENTRY</span><br><span class="line">   +0x1c8 KeyedWaitChain   : _LIST_ENTRY</span><br><span class="line">   +0x1d0 ExitStatus       : Int4B</span><br><span class="line">   +0x1d0 OfsChain         : Ptr32 Void</span><br><span class="line">   +0x1d4 PostBlockList    : _LIST_ENTRY</span><br><span class="line">   +0x1dc TerminationPort  : Ptr32 _TERMINATION_PORT</span><br><span class="line">   +0x1dc ReaperLink       : Ptr32 _ETHREAD</span><br><span class="line">   +0x1dc KeyedWaitValue   : Ptr32 Void</span><br><span class="line">   +0x1e0 ActiveTimerListLock : Uint4B</span><br><span class="line">   +0x1e4 ActiveTimerListHead : _LIST_ENTRY</span><br><span class="line">   +0x1ec Cid              : _CLIENT_ID</span><br><span class="line">   +0x1f4 LpcReplySemaphore : _KSEMAPHORE</span><br><span class="line">   +0x1f4 KeyedWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x208 LpcReplyMessage  : Ptr32 Void</span><br><span class="line">   +0x208 LpcWaitingOnPort : Ptr32 Void</span><br><span class="line">   +0x20c ImpersonationInfo : Ptr32 _PS_IMPERSONATION_INFORMATION</span><br><span class="line">   +0x210 IrpList          : _LIST_ENTRY</span><br><span class="line">   +0x218 TopLevelIrp      : Uint4B</span><br><span class="line">   +0x21c DeviceToVerify   : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +0x220 ThreadsProcess   : Ptr32 _EPROCESS</span><br><span class="line">   +0x224 StartAddress     : Ptr32 Void</span><br><span class="line">   +0x228 Win32StartAddress : Ptr32 Void</span><br><span class="line">   +0x228 LpcReceivedMessageId : Uint4B</span><br><span class="line">   +0x22c ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x234 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x238 ThreadLock       : _EX_PUSH_LOCK</span><br><span class="line">   +0x23c LpcReplyMessageId : Uint4B</span><br><span class="line">   +0x240 ReadClusterSize  : Uint4B</span><br><span class="line">   +0x244 GrantedAccess    : Uint4B</span><br><span class="line">   +0x248 CrossThreadFlags : Uint4B</span><br><span class="line">   +0x248 Terminated       : Pos 0, 1 Bit</span><br><span class="line">   +0x248 DeadThread       : Pos 1, 1 Bit</span><br><span class="line">   +0x248 HideFromDebugger : Pos 2, 1 Bit</span><br><span class="line">   +0x248 ActiveImpersonationInfo : Pos 3, 1 Bit</span><br><span class="line">   +0x248 SystemThread     : Pos 4, 1 Bit</span><br><span class="line">   +0x248 HardErrorsAreDisabled : Pos 5, 1 Bit</span><br><span class="line">   +0x248 BreakOnTermination : Pos 6, 1 Bit</span><br><span class="line">   +0x248 SkipCreationMsg  : Pos 7, 1 Bit</span><br><span class="line">   +0x248 SkipTerminationMsg : Pos 8, 1 Bit</span><br><span class="line">   +0x24c SameThreadPassiveFlags : Uint4B</span><br><span class="line">   +0x24c ActiveExWorker   : Pos 0, 1 Bit</span><br><span class="line">   +0x24c ExWorkerCanWaitUser : Pos 1, 1 Bit</span><br><span class="line">   +0x24c MemoryMaker      : Pos 2, 1 Bit</span><br><span class="line">   +0x250 SameThreadApcFlags : Uint4B</span><br><span class="line">   +0x250 LpcReceivedMsgIdValid : Pos 0, 1 Bit</span><br><span class="line">   +0x250 LpcExitThreadCalled : Pos 1, 1 Bit</span><br><span class="line">   +0x250 AddressSpaceOwner : Pos 2, 1 Bit</span><br><span class="line">   +0x254 ForwardClusterOnly : UChar</span><br><span class="line">   +0x255 DisablePageFaultClustering : UChar</span><br></pre></td></tr></table></figure>

<p>非快速系统调用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.text:8053E481 ; int __usercall KiSystemService@&lt;eax&gt;(int@&lt;edx&gt;, int@&lt;ebx&gt;, int@&lt;ebp&gt;, int@&lt;edi&gt;, int@&lt;esi&gt;, char)</span><br><span class="line">.text:8053E481 _KiSystemService proc near              ; CODE XREF: ZwAcceptConnectPort(x,x,x,x,x,x)+C↑p</span><br><span class="line">.text:8053E481                                         ; ZwAccessCheck(x,x,x,x,x,x,x,x)+C↑p ...</span><br><span class="line">.text:8053E481</span><br><span class="line">.text:8053E481 arg_0           = dword ptr  4</span><br><span class="line">.text:8053E481</span><br><span class="line">.text:8053E481                 push    0               ; KTrap_Frame+0x64,ErrorCode</span><br><span class="line">.text:8053E483                 push    ebp</span><br><span class="line">.text:8053E484                 push    ebx</span><br><span class="line">.text:8053E485                 push    esi</span><br><span class="line">.text:8053E486                 push    edi</span><br><span class="line">.text:8053E487                 push    fs</span><br><span class="line">.text:8053E489                 mov     ebx, 30h ; &#x27;0&#x27;  ; 为fs赋值，指向KPCR结构体</span><br><span class="line">.text:8053E48E                 mov     fs, bx</span><br><span class="line">.text:8053E491                 assume fs:nothing</span><br><span class="line">.text:8053E491                 push    dword ptr ds:0FFDFF000h ; 保存老的ExceptionList</span><br><span class="line">.text:8053E497                 mov     dword ptr ds:0FFDFF000h, 0FFFFFFFFh</span><br><span class="line">.text:8053E4A1                 mov     esi, ds:0FFDFF124h ; 得到当前线程的执行信息，是一个_KTHREAD结构体。</span><br><span class="line">.text:8053E4A7                 push    dword ptr [esi+140h] ; 保存以前的PreviousMode</span><br><span class="line">.text:8053E4AD                 sub     esp, 48h        ; esp指向_KTrap_Frame</span><br><span class="line">.text:8053E4B0                 mov     ebx, [esp+6Ch]  ; 系统调用前的CS寄存器的值</span><br><span class="line">.text:8053E4B4                 and     ebx, 1          ; 0环是0，三环是1</span><br><span class="line">.text:8053E4B7                 mov     [esi+140h], bl  ; 结果保存到PreviousMode里</span><br><span class="line">.text:8053E4BD                 mov     ebp, esp        ; ebp指向_KTrap_Frame</span><br><span class="line">.text:8053E4BF                 mov     ebx, [esi+134h] ; 取出以前的KTrap_Frame</span><br><span class="line">.text:8053E4C5                 mov     [ebp+3Ch], ebx  ; 暂存到KTrap_Frame结构体的edx位置处</span><br><span class="line">.text:8053E4C8                 mov     [esi+134h], ebp ; 保存新的_KTrap_Frame</span><br><span class="line">.text:8053E4CE                 cld</span><br><span class="line">.text:8053E4CF                 mov     ebx, [ebp+60h]  ; 3环的ebp</span><br><span class="line">.text:8053E4D2                 mov     edi, [ebp+68h]  ; 3环的eip</span><br><span class="line">.text:8053E4D5                 mov     [ebp+0Ch], edx  ; edx存的是三环参数指针</span><br><span class="line">.text:8053E4D8                 mov     dword ptr [ebp+8], 0BADB0D00h</span><br><span class="line">.text:8053E4DF                 mov     [ebp+0], ebx    ; 3环的ebp存到+0x000 DbgEbp: Uint4B</span><br><span class="line">.text:8053E4E2                 mov     [ebp+4], edi    ; 3环的eip存到+0x004 DbgEip: Uint4B</span><br><span class="line">.text:8053E4E5                 test    byte ptr [esi+2Ch], 0FFh ; 判断_KTHREAD的DebugActive，是否为-1，检查是否处于调试状态</span><br><span class="line">.text:8053E4E9                 jnz     Dr_kss_a</span><br><span class="line">.text:8053E4EF</span><br><span class="line">.text:8053E4EF loc_8053E4EF:                           ; CODE XREF: Dr_kss_a+10↑j</span><br><span class="line">.text:8053E4EF                                         ; Dr_kss_a+7C↑j</span><br><span class="line">.text:8053E4EF                 sti</span><br><span class="line">.text:8053E4F0                 jmp     loc_8053E5CD</span><br></pre></td></tr></table></figure>

<p>查找系统服务的过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">loc_8053E5CD:                           ; CODE XREF: _KiBBTUnexpectedRange+18↑j</span><br><span class="line">.text:8053E5CD                                         ; _KiSystemService+6F↑j</span><br><span class="line">.text:8053E5CD                 mov     edi, eax        ; eax是系统调用号</span><br><span class="line">.text:8053E5CF                 shr     edi, 8          ; 右移8位</span><br><span class="line">.text:8053E5D2                 and     edi, 30h        ; 检测第12位是否为1</span><br><span class="line">.text:8053E5D5                 mov     ecx, edi        ; ecx为Service类型的索引</span><br><span class="line">.text:8053E5D7                 add     edi, [esi+0E0h] ; KTHREAD-&gt;ServiceTable</span><br><span class="line">.text:8053E5DD                 mov     ebx, eax</span><br><span class="line">.text:8053E5DF                 and     eax, 0FFFh      ; 系统调用号只要后12位做索引</span><br><span class="line">.text:8053E5E4                 cmp     eax, [edi+8]    ; typedef struct _SYSTEM_SERVICE_TABLE&#123;</span><br><span class="line">.text:8053E5E4                                         ; PVOID ServiceTableBase;    //系统服务函数地址表</span><br><span class="line">.text:8053E5E4                                         ; PULONG ServiceCounterTableBase;</span><br><span class="line">.text:8053E5E4                                         ; ULONG NumberOfService;//服务函数的个数</span><br><span class="line">.text:8053E5E4                                         ; ULONG ParamTableBase;//参数表基址</span><br><span class="line">.text:8053E5E4                                         ; &#125;</span><br><span class="line">.text:8053E5E7                 jnb     _KiBBTUnexpectedRange</span><br><span class="line">.text:8053E5ED                 cmp     ecx, 10h</span><br><span class="line">.text:8053E5F0                 jnz     short loc_8053E60C ; KPCR-&gt;+0x518增加1</span><br><span class="line">.text:8053E5F2                 mov     ecx, ds:0FFDFF018h</span><br><span class="line">.text:8053E5F8                 xor     ebx, ebx</span><br><span class="line">.text:8053E5FA</span><br><span class="line">.text:8053E5FA loc_8053E5FA:                           ; DATA XREF: _KiTrap0E+113↓o</span><br><span class="line">.text:8053E5FA                 or      ebx, [ecx+0F70h]</span><br><span class="line">.text:8053E600                 jz      short loc_8053E60C ; KPCR-&gt;+0x518增加1</span><br><span class="line">.text:8053E602                 push    edx</span><br><span class="line">.text:8053E603                 push    eax</span><br><span class="line">.text:8053E604                 call    ds:_KeGdiFlushUserBatch</span><br><span class="line">.text:8053E60A                 pop     eax</span><br><span class="line">.text:8053E60B                 pop     edx</span><br><span class="line">.text:8053E60C</span><br><span class="line">.text:8053E60C loc_8053E60C:                           ; CODE XREF: _KiFastCallEntry+B0↑j</span><br><span class="line">.text:8053E60C                                         ; _KiFastCallEntry+C0↑j</span><br><span class="line">.text:8053E60C                 inc     dword ptr ds:0FFDFF638h ; KPCR-&gt;+0x518增加1</span><br><span class="line">.text:8053E612                 mov     esi, edx        ; edx存着3环参数指针</span><br><span class="line">.text:8053E614                 mov     ebx, [edi+0Ch]  ; 参数表基址</span><br><span class="line">.text:8053E617                 xor     ecx, ecx</span><br><span class="line">.text:8053E619                 mov     cl, [eax+ebx]   ; 参数表+调用号得到参数的个数</span><br><span class="line">.text:8053E61C                 mov     edi, [edi]      ; 系统服务地址表</span><br><span class="line">.text:8053E61E                 mov     ebx, [edi+eax*4] ; ebx调用函数的地址</span><br><span class="line">.text:8053E621                 sub     esp, ecx        ; 提升栈空间，保存参数用的</span><br><span class="line">.text:8053E623                 shr     ecx, 2</span><br><span class="line">.text:8053E626                 mov     edi, esp</span><br><span class="line">.text:8053E628                 cmp     esi, ds:_MmUserProbeAddress</span><br><span class="line">.text:8053E62E                 jnb     loc_8053E7DC</span><br><span class="line">.text:8053E634</span><br><span class="line">.text:8053E634 loc_8053E634:                           ; CODE XREF: _KiFastCallEntry+2A0↓j</span><br><span class="line">.text:8053E634                                         ; DATA XREF: _KiTrap0E+109↓o</span><br><span class="line">.text:8053E634                 rep movsd               ; copy执行</span><br><span class="line">.text:8053E636                 call    ebx             ; 执行目标函数</span><br></pre></td></tr></table></figure>

<p>查看SSDT的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dd KeServiceDescriptorTable</span><br><span class="line">dd KeServiceDescriptorTableShadow</span><br></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2021/09/24/Windows系统调用/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/09/17/Windbg用法/" >Windbg用法</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-09-17  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
		
            
            <p class="post">&lt;h2 id=&#34;在内核空间和用户空间工作的命令&#34;&gt;&lt;a href=&#34;#在内核空间和用户空间工作的命令&#34; class=&#34;headerlink&#34; title=&#34;在内核空间和用户空间工作的命令&#34;&gt;&lt;/a&gt;在内核空间和用户空间工作的命令&lt;/h2&gt;&lt;h3 id=&#34;dv-dt&#34;&gt;&lt;a href=&#34;#dv-dt&#34; class=&#34;headerlink&#34; title=&#34;dv/dt&#34;&gt;&lt;/a&gt;dv/dt&lt;/h3&gt;&lt;p&gt;当您进行源代码级调试时，可以使用“Display Local Variables”（dv） 命令，或者您可以打开本地变量窗口。&lt;/p&gt;
&lt;p&gt;“Display Type”(dt) 命令既可以显示struct的字段，也可以根据给定的struct类型解释给定地址处的内存。&lt;/p&gt;
&lt;h4 id=&#34;仅显示给定类型struct的顶级字段&#34;&gt;&lt;a href=&#34;#仅显示给定类型struct的顶级字段&#34; class=&#34;headerlink&#34; title=&#34;仅显示给定类型struct的顶级字段&#34;&gt;&lt;/a&gt;仅显示给定类型struct的顶级字段&lt;/h4&gt;&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;dt &amp;#123;structure type&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;: kd&amp;gt; dt nt!_EPROCESS&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   +&lt;span class=&#34;number&#34;&gt;0x000&lt;/span&gt; Pcb              : _KPROCESS&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   +&lt;span class=&#34;number&#34;&gt;0x438&lt;/span&gt; ProcessLock      : _EX_PUSH_LOCK&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   +&lt;span class=&#34;number&#34;&gt;0x440&lt;/span&gt; UniqueProcessId  : Ptr64 Void&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   +&lt;span class=&#34;number&#34;&gt;0x448&lt;/span&gt; ActiveProcessLinks : _LIST_ENTRY&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   +&lt;span class=&#34;number&#34;&gt;0x458&lt;/span&gt; RundownProtect   : _EX_RUNDOWN_REF&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&#34;递归显示struct定义&#34;&gt;&lt;a href=&#34;#递归显示struct定义&#34; class=&#34;headerlink&#34; title=&#34;递归显示struct定义&#34;&gt;&lt;/a&gt;递归显示struct定义&lt;/h4&gt;&lt;p&gt;要递归显示struct（和sub-struct）的字段：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;dt -r&amp;#123;depth&amp;#125; &amp;#123;structure type&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;: kd&amp;gt; dt -r2 nt!_EPROCESS&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   +&lt;span class=&#34;number&#34;&gt;0x000&lt;/span&gt; Pcb              : _KPROCESS&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      +&lt;span class=&#34;number&#34;&gt;0x000&lt;/span&gt; Header           : _DISPATCHER_HEADER&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;         +&lt;span class=&#34;number&#34;&gt;0x000&lt;/span&gt; Lock             : Int4B&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;         +&lt;span class=&#34;number&#34;&gt;0x000&lt;/span&gt; LockNV           : Int4B&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;         +&lt;span class=&#34;number&#34;&gt;0x000&lt;/span&gt; Type             : UChar&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&#34;按struct显示给定地址出内存中的值：&#34;&gt;&lt;a href=&#34;#按struct显示给定地址出内存中的值：&#34; class=&#34;headerlink&#34; title=&#34;按struct显示给定地址出内存中的值：&#34;&gt;&lt;/a&gt;按struct显示给定地址出内存中的值：&lt;/h4&gt;&lt;p&gt;根据结构定义解释给定地址处的内存：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;dt &amp;#123;structure type&amp;#125; &amp;#123;address&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;: kd&amp;gt; dt nt!_EPROCESS ffffb38b26516340&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   +&lt;span class=&#34;number&#34;&gt;0x000&lt;/span&gt; Pcb              : _KPROCESS&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   +&lt;span class=&#34;number&#34;&gt;0x438&lt;/span&gt; ProcessLock      : _EX_PUSH_LOCK&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   +&lt;span class=&#34;number&#34;&gt;0x440&lt;/span&gt; UniqueProcessId  : &lt;span class=&#34;number&#34;&gt;0x00000000&lt;/span&gt;`&lt;span class=&#34;number&#34;&gt;00001858&lt;/span&gt; Void&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   +&lt;span class=&#34;number&#34;&gt;0x448&lt;/span&gt; ActiveProcessLinks : _LIST_ENTRY [ &lt;span class=&#34;number&#34;&gt;0xffffb38b&lt;/span&gt;`&lt;span class=&#34;number&#34;&gt;25&lt;/span&gt;aab748 - &lt;span class=&#34;number&#34;&gt;0xffffb38b&lt;/span&gt;`&lt;span class=&#34;number&#34;&gt;263&lt;/span&gt;da4c8 ]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   +&lt;span class=&#34;number&#34;&gt;0x458&lt;/span&gt; RundownProtect   : _EX_RUNDOWN_REF&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   +&lt;span class=&#34;number&#34;&gt;0x460&lt;/span&gt; Flags2           : &lt;span class=&#34;number&#34;&gt;0x200d080&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;sxe-ld&#34;&gt;&lt;a href=&#34;#sxe-ld&#34; class=&#34;headerlink&#34; title=&#34;sxe ld&#34;&gt;&lt;/a&gt;sxe ld&lt;/h3&gt;&lt;h4 id=&#34;模块加载时中断&#34;&gt;&lt;a href=&#34;#模块加载时中断&#34; class=&#34;headerlink&#34; title=&#34;模块加载时中断&#34;&gt;&lt;/a&gt;模块加载时中断&lt;/h4&gt;&lt;p&gt;Set Exception (sx) 命令可用于在发生特定事件时中断。形式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Enable: sxe&lt;/li&gt;
&lt;li&gt;Ignore: sxi&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以触发调试器中断的事件有很多，现在只看模块加载，在进行用户空间调试时，“模块”可以是 .exe 或 .dll。 在内核模式下，模块是 .sys 内核驱动程序（或.exe NT的内核本身。）&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sxe ld&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这条命令会使调试器将在每个模块加载时中断。&lt;/p&gt;
&lt;h4 id=&#34;在-sx-中断时自动运行命令&#34;&gt;&lt;a href=&#34;#在-sx-中断时自动运行命令&#34; class=&#34;headerlink&#34; title=&#34;在 sx* 中断时自动运行命令&#34;&gt;&lt;/a&gt;在 sx* 中断时自动运行命令&lt;/h4&gt;&lt;p&gt;sx*有个可可选的参数 &lt;code&gt; -c &amp;quot;some ; list ; of ; commands&amp;quot;&lt;/code&gt;;一个有用的命令是“.lastevent”，它可以打印出关于最后发生的事件的信息。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sxe -c &lt;span class=&#34;string&#34;&gt;&amp;quot;.lastevent&amp;quot;&lt;/span&gt; ld&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果您只想查看模块何时加载，而不是实际停止（例如，仅查看引导时加载内核驱动程序的顺序），您可以使用：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sxi -c &lt;span class=&#34;string&#34;&gt;&amp;quot;.lastevent ; g&amp;quot;&lt;/span&gt; ld&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&#34;忽略-禁用断点：&#34;&gt;&lt;a href=&#34;#忽略-禁用断点：&#34; class=&#34;headerlink&#34; title=&#34;忽略/禁用断点：&#34;&gt;&lt;/a&gt;忽略/禁用断点：&lt;/h4&gt;&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sxi -c &lt;span class=&#34;string&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt; ld&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;lm-List-Modules&#34;&gt;&lt;a href=&#34;#lm-List-Modules&#34; class=&#34;headerlink&#34; title=&#34;lm:List Modules&#34;&gt;&lt;/a&gt;lm:List Modules&lt;/h3&gt;&lt;p&gt;List Modules (Userspace &amp;amp; Kernel)：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;lm&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;List Modules Userspace only：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;lm u&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;List Modules kernel only：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;lm k&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;List Modules(按字母排序)：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;lm sm&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;列出的模块带着系统路径：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;lm f&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;组合命令输出方式：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;lm ksmf&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;给lm命令加一个v选项，获取冗长的输出信息。&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;lm ksmv&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;查看地址属于哪个模块：&lt;/p&gt;
<p>
		

	

	</div>
  <a type="button" href="/2021/09/17/Windbg用法/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="在内核空间和用户空间工作的命令"><a href="#在内核空间和用户空间工作的命令" class="headerlink" title="在内核空间和用户空间工作的命令"></a>在内核空间和用户空间工作的命令</h2><h3 id="dv-dt"><a href="#dv-dt" class="headerlink" title="dv/dt"></a>dv/dt</h3><p>当您进行源代码级调试时，可以使用“Display Local Variables”（dv） 命令，或者您可以打开本地变量窗口。</p>
<p>“Display Type”(dt) 命令既可以显示struct的字段，也可以根据给定的struct类型解释给定地址处的内存。</p>
<h4 id="仅显示给定类型struct的顶级字段"><a href="#仅显示给定类型struct的顶级字段" class="headerlink" title="仅显示给定类型struct的顶级字段"></a>仅显示给定类型struct的顶级字段</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dt &#123;structure type&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: kd&gt; dt nt!_EPROCESS</span><br><span class="line">   +<span class="number">0x000</span> Pcb              : _KPROCESS</span><br><span class="line">   +<span class="number">0x438</span> ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x440</span> UniqueProcessId  : Ptr64 Void</span><br><span class="line">   +<span class="number">0x448</span> ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x458</span> RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="递归显示struct定义"><a href="#递归显示struct定义" class="headerlink" title="递归显示struct定义"></a>递归显示struct定义</h4><p>要递归显示struct（和sub-struct）的字段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dt -r&#123;depth&#125; &#123;structure type&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: kd&gt; dt -r2 nt!_EPROCESS</span><br><span class="line">   +<span class="number">0x000</span> Pcb              : _KPROCESS</span><br><span class="line">      +<span class="number">0x000</span> Header           : _DISPATCHER_HEADER</span><br><span class="line">         +<span class="number">0x000</span> Lock             : Int4B</span><br><span class="line">         +<span class="number">0x000</span> LockNV           : Int4B</span><br><span class="line">         +<span class="number">0x000</span> Type             : UChar</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="按struct显示给定地址出内存中的值："><a href="#按struct显示给定地址出内存中的值：" class="headerlink" title="按struct显示给定地址出内存中的值："></a>按struct显示给定地址出内存中的值：</h4><p>根据结构定义解释给定地址处的内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dt &#123;structure type&#125; &#123;address&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: kd&gt; dt nt!_EPROCESS ffffb38b26516340</span><br><span class="line">   +<span class="number">0x000</span> Pcb              : _KPROCESS</span><br><span class="line">   +<span class="number">0x438</span> ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x440</span> UniqueProcessId  : <span class="number">0x00000000</span>`<span class="number">00001858</span> Void</span><br><span class="line">   +<span class="number">0x448</span> ActiveProcessLinks : _LIST_ENTRY [ <span class="number">0xffffb38b</span>`<span class="number">25</span>aab748 - <span class="number">0xffffb38b</span>`<span class="number">263</span>da4c8 ]</span><br><span class="line">   +<span class="number">0x458</span> RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +<span class="number">0x460</span> Flags2           : <span class="number">0x200d080</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="sxe-ld"><a href="#sxe-ld" class="headerlink" title="sxe ld"></a>sxe ld</h3><h4 id="模块加载时中断"><a href="#模块加载时中断" class="headerlink" title="模块加载时中断"></a>模块加载时中断</h4><p>Set Exception (sx) 命令可用于在发生特定事件时中断。形式如下：</p>
<ul>
<li>Enable: sxe</li>
<li>Ignore: sxi</li>
</ul>
<p>可以触发调试器中断的事件有很多，现在只看模块加载，在进行用户空间调试时，“模块”可以是 .exe 或 .dll。 在内核模式下，模块是 .sys 内核驱动程序（或.exe NT的内核本身。）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sxe ld</span><br></pre></td></tr></table></figure>

<p>这条命令会使调试器将在每个模块加载时中断。</p>
<h4 id="在-sx-中断时自动运行命令"><a href="#在-sx-中断时自动运行命令" class="headerlink" title="在 sx* 中断时自动运行命令"></a>在 sx* 中断时自动运行命令</h4><p>sx*有个可可选的参数 <code> -c &quot;some ; list ; of ; commands&quot;</code>;一个有用的命令是“.lastevent”，它可以打印出关于最后发生的事件的信息。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sxe -c <span class="string">&quot;.lastevent&quot;</span> ld</span><br></pre></td></tr></table></figure>

<p>如果您只想查看模块何时加载，而不是实际停止（例如，仅查看引导时加载内核驱动程序的顺序），您可以使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sxi -c <span class="string">&quot;.lastevent ; g&quot;</span> ld</span><br></pre></td></tr></table></figure>

<h4 id="忽略-禁用断点："><a href="#忽略-禁用断点：" class="headerlink" title="忽略/禁用断点："></a>忽略/禁用断点：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sxi -c <span class="string">&quot;&quot;</span> ld</span><br></pre></td></tr></table></figure>

<h3 id="lm-List-Modules"><a href="#lm-List-Modules" class="headerlink" title="lm:List Modules"></a>lm:List Modules</h3><p>List Modules (Userspace &amp; Kernel)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lm</span><br></pre></td></tr></table></figure>

<p>List Modules Userspace only：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lm u</span><br></pre></td></tr></table></figure>

<p>List Modules kernel only：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lm k</span><br></pre></td></tr></table></figure>

<p>List Modules(按字母排序)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lm sm</span><br></pre></td></tr></table></figure>

<p>列出的模块带着系统路径：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lm f</span><br></pre></td></tr></table></figure>

<p>组合命令输出方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lm ksmf</span><br></pre></td></tr></table></figure>

<p>给lm命令加一个v选项，获取冗长的输出信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lm ksmv</span><br></pre></td></tr></table></figure>

<p>查看地址属于哪个模块：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lm a address</span><br></pre></td></tr></table></figure>

<h3 id="load-加载第三方插件"><a href="#load-加载第三方插件" class="headerlink" title="!load 加载第三方插件"></a>!load 加载第三方插件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!load </span><br><span class="line">!unload </span><br></pre></td></tr></table></figure>

<h2 id="kernel-only-command"><a href="#kernel-only-command" class="headerlink" title="kernel-only command"></a>kernel-only command</h2><h3 id="process-process"><a href="#process-process" class="headerlink" title="!process/.process"></a>!process/.process</h3><p>display 当前进程的context</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!process <span class="number">-1</span> [flags]</span><br></pre></td></tr></table></figure>

<p>列出所有进程的context</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!process <span class="number">0</span> [flags]</span><br></pre></td></tr></table></figure>

<p>通过进程名查看进程的context</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!process <span class="number">0</span> [flags] [exec name]</span><br></pre></td></tr></table></figure>

<p>通过进程的pid查看进程context</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!process [pid] [flags]</span><br></pre></td></tr></table></figure>

<p>将进程上下文切换为目标进程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.process /i /r /p [<span class="string">&quot;PROCESS&quot;</span> address from !process output]</span><br></pre></td></tr></table></figure>

<h3 id="rdmsr-wrmsr-Reading-Writing-Model-Specific-Registers-MSRs"><a href="#rdmsr-wrmsr-Reading-Writing-Model-Specific-Registers-MSRs" class="headerlink" title="rdmsr/wrmsr: Reading/Writing Model Specific Registers (MSRs)"></a>rdmsr/wrmsr: Reading/Writing Model Specific Registers (MSRs)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rdmsr [MSR #]</span><br><span class="line">wrmsr [MSR #] [value to write]</span><br></pre></td></tr></table></figure>

<h3 id="ms-gdt-Examine-the-Global-Descriptor-Table-GDT"><a href="#ms-gdt-Examine-the-Global-Descriptor-Table-GDT" class="headerlink" title="!ms_gdt: Examine the Global Descriptor Table (GDT)"></a>!ms_gdt: Examine the Global Descriptor Table (GDT)</h3><h3 id="idt-ms-idt-Examine-the-Interrupt-Descriptor-Table-IDT"><a href="#idt-ms-idt-Examine-the-Interrupt-Descriptor-Table-IDT" class="headerlink" title="!idt/!ms_idt: Examine the Interrupt Descriptor Table (IDT)"></a>!idt/!ms_idt: Examine the Interrupt Descriptor Table (IDT)</h3><h3 id="pte-Examining-Virtual-Memory-and-Page-Tables"><a href="#pte-Examining-Virtual-Memory-and-Page-Tables" class="headerlink" title="!pte: Examining Virtual Memory and Page Tables"></a>!pte: Examining Virtual Memory and Page Tables</h3><h3 id="pool"><a href="#pool" class="headerlink" title="!pool:"></a>!pool:</h3><p>将内存地址与数据结构或驱动程序相关联</p>
<h3 id="irql-Examining-Windows-Interrupt-Request-Level-IRQL"><a href="#irql-Examining-Windows-Interrupt-Request-Level-IRQL" class="headerlink" title="!irql: Examining Windows Interrupt Request Level (IRQL)"></a>!irql: Examining Windows Interrupt Request Level (IRQL)</h3>
	
	</div>
  <a type="button" href="/2021/09/17/Windbg用法/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/09/09/遇到hexo莫名其妙的bug/" >遇到hexo莫名其妙的bug</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-09-09  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/09/09/遇到hexo莫名其妙的bug/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<p>最近blog换了hexo，遇到一些坑，记录下。图片就是不显示，遂看看是哪里出了问题用浏览器的查看元素查看图片的位置，发现图片的引用路径里不知道为啥多了个 <code>/.io//</code>,百度谷歌后无果，提了个issue没人理我。然后想着写个脚本给改过来。就是每次generate后都要执行一遍，有点麻烦。不过图片显示的问题解决了。脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span>(<span class="params">fd</span>):</span></span><br><span class="line">    html = fd.read()</span><br><span class="line">    html = html.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    s = html.find(<span class="string">&#x27;&lt;img src=&quot;/.io//&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">    html2 = html.replace(<span class="string">&#x27;&lt;img src=&quot;/.io//&#x27;</span>, <span class="string">&#x27;&lt;img src=&quot;&#x27;</span>)</span><br><span class="line">    fd.seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    fd.write(html2.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">&quot;./public/&quot;</span>):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            fname = os.path.join(root, file)</span><br><span class="line">            <span class="keyword">if</span> (file == <span class="string">&quot;index.html&quot;</span>):</span><br><span class="line">                <span class="comment">#print(fname)</span></span><br><span class="line">                fd = <span class="built_in">open</span>(fname, <span class="string">&quot;rb+&quot;</span>)</span><br><span class="line">                modify(fd)</span><br><span class="line">                fd.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2021/09/09/遇到hexo莫名其妙的bug/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/09/07/CVE-2021-3156分析/" >CVE-2021-3156分析</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-09-07  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/09/07/CVE-2021-3156分析/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudoedit -s &#x27;\&#x27; `perl -e &#x27;print &quot;A&quot; x 64&#x27;`</span><br></pre></td></tr></table></figure>

<p>崩了</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>如果sudo在一个shell环境中被执行了：</p>
<ul>
<li>使用 -s 参数选项设置sudo的MODE_SHELL标志；</li>
<li>或者通过 -i 参数选项设置sudo的MODE_SHELL和MODE_LOGIN_SHELL标志；然后在sudo的main()的开头调用parse_args()重写argv</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Parse command line arguments. */</span></span><br><span class="line"> sudo_mode = <span class="built_in">parse_args</span>(argc, argv, &amp;nargc, &amp;nargv, &amp;settings, &amp;env_add);</span><br><span class="line"> <span class="built_in">sudo_debug_printf</span>(SUDO_DEBUG_DEBUG, <span class="string">&quot;sudo_mode %d&quot;</span>, sudo_mode);</span><br></pre></td></tr></table></figure>

<p>直接定位到漏洞函数处：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">set_cmnd</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* set user_args */</span></span><br><span class="line">    <span class="keyword">if</span> (NewArgc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *to, *from, **av;</span><br><span class="line">        <span class="keyword">size_t</span> size, n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Alloc and build up user_args. */</span></span><br><span class="line">        <span class="keyword">for</span> (size = <span class="number">0</span>, av = NewArgv + <span class="number">1</span>; *av; av++)</span><br><span class="line">        size += <span class="built_in">strlen</span>(*av) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span> || (user_args = <span class="built_in">malloc</span>(size)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">sudo_warnx</span>(<span class="built_in">U_</span>(<span class="string">&quot;%s: %s&quot;</span>), __func__, <span class="built_in">U_</span>(<span class="string">&quot;unable to allocate memory&quot;</span>));</span><br><span class="line">        <span class="built_in">debug_return_int</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ISSET</span>(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * When running a command via a shell, the sudo front-end</span></span><br><span class="line"><span class="comment">         * escapes potential meta chars.  We unescape non-spaces</span></span><br><span class="line"><span class="comment">         * for sudoers matching and logging purposes.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (to = user_args, av = NewArgv + <span class="number">1</span>; (from = *av); av++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (*from) &#123;</span><br><span class="line">            <span class="keyword">if</span> (from[<span class="number">0</span>] == <span class="string">&#x27;\\&#x27;</span> &amp;&amp; !<span class="built_in">isspace</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>)from[<span class="number">1</span>]))</span><br><span class="line">                from++;</span><br><span class="line">            *to++ = *from++;</span><br><span class="line">            &#125;</span><br><span class="line">            *to++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *--to = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (to = user_args, av = NewArgv + <span class="number">1</span>; *av; av++) &#123;</span><br><span class="line">            n = <span class="built_in">strlcpy</span>(to, *av, size - (to - user_args));</span><br><span class="line">            <span class="keyword">if</span> (n &gt;= size - (to - user_args)) &#123;</span><br><span class="line">            <span class="built_in">sudo_warnx</span>(<span class="built_in">U_</span>(<span class="string">&quot;internal error, %s overflow&quot;</span>), __func__);</span><br><span class="line">            <span class="built_in">debug_return_int</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            to += n;</span><br><span class="line">            *to++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *--to = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((user_base = <span class="built_in">strrchr</span>(user_cmnd, <span class="string">&#x27;/&#x27;</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">    user_base++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    user_base = user_cmnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">update_defaults</span>(SETDEF_CMND, <span class="literal">false</span>)) &#123;</span><br><span class="line">    <span class="built_in">log_warningx</span>(SLOG_SEND_MAIL|SLOG_NO_STDERR,</span><br><span class="line">        <span class="built_in">N_</span>(<span class="string">&quot;problem with defaults entries&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">debug_return_int</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若from[0]为\并且from[1]是NULL结束字符（不为空格），因此进入if条件 from++后此时指向NULL结束字符，而下一行from++指向下个字符串开头，若该字符串存在，则继续这个while循环，因此造成了堆溢出。通过动态调试可见，程序越界读取\后的“AAAAA….”字符，进入下一轮while循环：</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>Qualys团队提供了三种漏洞利用手段：</p>
<p>1.<code>struct sudo_hook_entry</code>覆盖:</p>
<p>sudo程序在process_hooks_getenv()函数crash了；因为我们直接覆盖了函数getenv_fn()的指针。一个<code>struct sudo_hook_entry</code>的结构体，修改<code>struct sudo_hook_entry</code>实例可以实现任意代码执行的目的。</p>
<p>但是这里会有一个其他的问题，就是ASLR，我们可以通过部分写入的方式绕过ASLR，</p>
<p>2.<code>struct service_user</code>覆盖</p>
<p>Qualys团队分析第二个cash，发现crash在了nss_load_library()的函数上。crash的原因是我们覆盖了library的指针。我们可以通过重写<code>struct service_user</code>结构体，实现任意代码的执行。我们把<code>ni-&gt;library</code>覆盖为NULL,<code>ni-&gt;name</code>(初始化为systemd)覆盖为X/X,</p>
<p>service_user结构体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nss/nsswitch.h#L61</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">service_user</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* And the link to the next entry.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">service_user</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* Action according to result.  */</span></span><br><span class="line">  lookup_actions actions[<span class="number">5</span>];</span><br><span class="line">  <span class="comment">/* Link to the underlying library object.  */</span></span><br><span class="line">  service_library *library;</span><br><span class="line">  <span class="comment">/* Collection of known functions.  */</span></span><br><span class="line">  <span class="keyword">void</span> *known;</span><br><span class="line">  <span class="comment">/* Name of the service (`files&#x27;, `dns&#x27;, `nis&#x27;, ...).  */</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">0</span>];</span><br><span class="line">&#125; service_user;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="number">327</span> <span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line"><span class="number">328</span> <span class="built_in">nss_load_library</span> (service_user *ni)</span><br><span class="line"><span class="number">329</span> &#123;</span><br><span class="line"><span class="number">330</span>   <span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">331</span>     &#123;</span><br><span class="line">...</span><br><span class="line"><span class="number">338</span>       ni-&gt;library = <span class="built_in">nss_new_service</span> (service_table ?: &amp;default_table,</span><br><span class="line"><span class="number">339</span>                                      ni-&gt;name);</span><br><span class="line">...</span><br><span class="line"><span class="number">342</span>     &#125;</span><br><span class="line"><span class="number">343</span></span><br><span class="line"><span class="number">344</span>   <span class="keyword">if</span> (ni-&gt;library-&gt;lib_handle == <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">345</span>     &#123;</span><br><span class="line"><span class="number">346</span>       <span class="comment">/* Load the shared library.  */</span></span><br><span class="line"><span class="number">347</span>       <span class="keyword">size_t</span> shlen = (<span class="number">7</span> + <span class="built_in">strlen</span> (ni-&gt;name) + <span class="number">3</span></span><br><span class="line"><span class="number">348</span>                       + <span class="built_in">strlen</span> (__nss_shlib_revision) + <span class="number">1</span>);</span><br><span class="line"><span class="number">349</span>       <span class="keyword">int</span> saved_errno = errno;</span><br><span class="line"><span class="number">350</span>       <span class="keyword">char</span> shlib_name[shlen];</span><br><span class="line"><span class="number">351</span></span><br><span class="line"><span class="number">352</span>       <span class="comment">/* Construct shared object name.  */</span></span><br><span class="line"><span class="number">353</span>       __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,</span><br><span class="line"><span class="number">354</span>                                               <span class="string">&quot;libnss_&quot;</span>),</span><br><span class="line"><span class="number">355</span>                                     ni-&gt;name),</span><br><span class="line"><span class="number">356</span>                           <span class="string">&quot;.so&quot;</span>),</span><br><span class="line"><span class="number">357</span>                 __nss_shlib_revision);</span><br><span class="line"><span class="number">358</span></span><br><span class="line"><span class="number">359</span>       ni-&gt;library-&gt;lib_handle = __libc_dlopen (shlib_name);</span><br><span class="line">------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>在353-357行，构造分享库名字为”libnss_X/X.so.2”，在359行从当前目录中加载名字为”libnss_X/X.so.2”的动态链接库。并执行_init构造函数。</p>
<p>3.def_timestampdir覆盖。</p>
<p>第三种利用方式不是直接从sudo的crash中，是通过观察获得的。在Fuzzing的时候sudo创建了数十个新的目录（AAAA AAAAA等），这些目录中的每一个都属于 root 并且只包含一个小的文件，以我自己的用户命名：sudo 的时间戳文件——我们显然覆盖了 def_timestampdir，sudo 的时间戳目录的名称。如果我们通过目录名覆盖def_timestampdir，然后我们可以与 sudo 的 ts_mkdirs() 竞争，创建一个符号链接到任意文件。<br>可以以root的身份打开这个任意文件，写struct timestamp_entry到它的里边。但是现在有两个问题：</p>
<p>(1)如果 Sudo 的 timestamp_open() 指向的文件早于启动时间，则会删除我们的任意符号链接。 我们能够通过创建一个非常旧的时间戳文件（来自 Unix 时代），等待直到 timestamp_open() 删除它，并通过与 timestamp_open() 竞争来创建我们最终的、任意的符号链接来解决第一个问题。</p>
<p>(2)我们不控制写入任意文件的 struct timestamp_entry 的内容。 据我们所知，我们只控制三个字节（进程 ID 或结构时间规范），我们无法将这个三字节写入转换为完全 root 权限。</p>
<p>然而我们可以通过sudo的timestamp_lock()的一个小bug规避掉第二个问题。如果我们在与 ts_mkdirs() 和 timestamp_open() 的两个之间利用，并且我们的任意符号链接指向 /etc/passwd，那么这个文件将以 root 身份打开，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------------</span><br><span class="line"> <span class="number">65</span> <span class="class"><span class="keyword">struct</span> <span class="title">timestamp_entry</span> &#123;</span></span><br><span class="line"> <span class="number">66</span>     <span class="keyword">unsigned</span> <span class="keyword">short</span> version;     <span class="comment">/* version number */</span></span><br><span class="line"> <span class="number">67</span>     <span class="keyword">unsigned</span> <span class="keyword">short</span> size;        <span class="comment">/* entry size */</span></span><br><span class="line"> <span class="number">68</span>     <span class="keyword">unsigned</span> <span class="keyword">short</span> type;        <span class="comment">/* TS_GLOBAL, TS_TTY, TS_PPID */</span></span><br><span class="line"> ..</span><br><span class="line"> <span class="number">78</span> &#125;;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"> <span class="number">305</span> <span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line"> <span class="number">306</span> <span class="built_in">ts_write</span>(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *fname, struct timestamp_entry *entry, <span class="keyword">off_t</span> offset)</span><br><span class="line"> <span class="number">307</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="number">318</span>         nwritten = <span class="built_in">pwrite</span>(fd, entry, entry-&gt;size, offset);</span><br><span class="line"> ...</span><br><span class="line"> <span class="number">350</span> &#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"> <span class="number">619</span> <span class="keyword">bool</span></span><br><span class="line"> <span class="number">620</span> <span class="built_in">timestamp_lock</span>(<span class="keyword">void</span> *vcookie, struct passwd *pw)</span><br><span class="line"> <span class="number">621</span> &#123;</span><br><span class="line"> <span class="number">622</span>     <span class="class"><span class="keyword">struct</span> <span class="title">ts_cookie</span> *<span class="title">cookie</span> =</span> vcookie;</span><br><span class="line"> <span class="number">623</span>     <span class="class"><span class="keyword">struct</span> <span class="title">timestamp_entry</span> <span class="title">entry</span>;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="number">644</span>     nread = <span class="built_in">read</span>(cookie-&gt;fd, &amp;entry, <span class="built_in"><span class="keyword">sizeof</span></span>(entry));</span><br><span class="line"> <span class="number">645</span>     <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="number">652</span>     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.type != TS_LOCKEXCL) &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="number">657</span>         <span class="keyword">if</span> (<span class="built_in">ts_write</span>(cookie-&gt;fd, cookie-&gt;fname, &amp;entry, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>在644行，/etc/passwd文件的头0x38字节被读到栈上的<code>timestamp_entry</code>结构体中,</p>
<p>在652行，<code>entry.type</code> is 0x783a (“:x”), 不是TS_LOCKEXCL;</p>
<p>在657和318行,<code>entry-&gt;size</code>个字节，从栈上的entry被写到/etc/passwd中，但是<code>entry-&gt;size</code> 实际上是0x746f (“ot”), 不是sizeof(struct timestamp_entry)</p>
<p>之后我们向/etc/passwd中注入了一个与root拥有相同权限的新用户，从而完成提权。</p>

	
	</div>
  <a type="button" href="/2021/09/07/CVE-2021-3156分析/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/09/02/高级IO/" >高级I/O</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-09-02  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/09/02/高级IO/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h2><p>如果某些文件类型(如读管道、终端设备和网络设备)的数据并不存在，读操作可能会使调用者永远阻塞；</p>
<p>如果数据不能被相同的文件类型立即接受(如：管道中无空间、网路流控制)，写操作可能会使调用者永远阻塞；</p>
<p>在某些条件发生之前打开某些文件可能回发生阻塞(如要打开一个终端设备，需要先等待与之连接的调制解调器应答，又如若以只写模式打开FIFO，那么在没有其他进程已用读模式打开该FIFO时也要等待)；</p>
<p>对已经加上强制性记录锁的文件进行读写；</p>
<p>某些ioctl操作；</p>
<p>某些进程间通信函数。</p>
<p>非阻塞I/O使我们可以发出open、read和write这样的I/O操作，并使这些操作不会永远阻塞。如果这种操作不能完成，则调用立即出错返回，表示该操作如继续执行将阻塞。</p>
<p>对于一个给定的描述符，有两种为其指定非阻塞I/O的方法。</p>
<pre><code>1.如果调用open获得的描述符，则可以指定O_NONBLOCK标志。
2.对于已经打开的一个描述符，则可调用fcntl，由该函数打开O_NONBLOCK文件状态标志。
</code></pre>
<h2 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h2><p>记录锁（record locking）的功能是：当第一个进程正在读或修改文件的某个部分时，使用记录锁可以阻止其他进程修改同一文件区。</p>
<p>fcntl记录锁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcnt1.h&gt;</span>int fcnt1(int fd, int cmd, ...<span class="comment">/* struct flock *flockptr */</span>);</span></span><br></pre></td></tr></table></figure>

<p>返回值：若成功，依赖于cmd（见下），否则，返回−1对于记录锁，cmd是F_GETLK、F_SETLK或F_SETLKW。第三个参数（我们将调用flockptr）是一个指向flock结构的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> l_type;<span class="comment">/* F_RDLCK(共享读锁), F_WRLCK（独占性写锁）, or F_UNLCK（解锁一个区域） */</span></span><br><span class="line">    <span class="keyword">short</span> l_whence;<span class="comment">/* SEEK_SET, SEEK_CUR, or SEEK_END */</span></span><br><span class="line">    <span class="keyword">off_t</span> l_start;<span class="comment">/* offset in bytes, relative to l_whence */</span></span><br><span class="line">    <span class="keyword">off_t</span> l_len;<span class="comment">/* length, in bytes; 0 means lock to EOF */</span></span><br><span class="line">    <span class="keyword">pid_t</span> l_pid;<span class="comment">/* returned with F_GETLK */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="I-O多路转接"><a href="#I-O多路转接" class="headerlink" title="I/O多路转接"></a>I/O多路转接</h2><p>果必须从两个描述符读，在这种情况下，我们不能在任一个描述符上进行阻塞读（read），否则可能会因为被阻塞在一个描述符的读操作上而导致另一个描述符即使有数据也无法处理。</p>
<p>为了使用这种技术，先构造一张我们感兴趣的描述符（通常都不止一个）的列表，然后调用一个函数，直到这些描述符中的一个已准备好进行I/O时，该函数才返回。poll、pselect和select这3个函数使我们能够执行I/O多路转接。在从这些函数返回时，进程会被告知哪些描述符已准备好可以进行I/O。</p>
<h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_read</span><span class="params">(struct aiocb *aiocb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_write</span><span class="params">(struct aiocb *aiocb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_fsync</span><span class="params">(<span class="keyword">int</span> op, struct aiocb *aiocb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_error</span><span class="params">(<span class="keyword">const</span> struct aiocb *aiocb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">aio_return</span><span class="params">(<span class="keyword">const</span> struct aiocb *aiocb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_suspend</span><span class="params">(<span class="keyword">const</span> struct aiocb *<span class="keyword">const</span> list[], <span class="keyword">int</span> nent, <span class="keyword">const</span> struct timespec *timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_cancel</span><span class="params">(<span class="keyword">int</span> fd, struct aiocb *aiocb)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="函数readv和writev"><a href="#函数readv和writev" class="headerlink" title="函数readv和writev"></a>函数readv和writev</h2><p>readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函数称为散布读（scatter read）和聚集写（gather write）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span>s</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">readv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="函数readn和writen"><a href="#函数readn和writen" class="headerlink" title="函数readn和writen"></a>函数readn和writen</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I/O"></a>存储映射I/O</h2><p>存储映射I/O（memory-mapped I/O）能将一个磁盘文件映射到存储空间中的一个缓冲区上，于是，当从缓冲区中取数据时，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区时，相应字节就自动写入文件。这样，就可以在不使用read和write的情况下执行I/O。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flag, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> off)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len)</span></span></span><br></pre></td></tr></table></figure>

<p>返回值：若成功，返回映射区的起始地址；若出错，返回MAP_FAILED。</p>
<p>addr参数用于指定映射存储区的起始地址。通常将其设置为0，这表示由系统选择该映射区的起始地址。此函数的返回值是该映射区的起始地址。</p>
<p>fd参数是指定要被映射文件的描述符。在文件映射到地址空间之前，必须先打开该文件。</p>
<p>len参数是映射的字节数，</p>
<p>off是要映射字节在文件中的起始偏移量（有关off值的一些限制将在后面说明）。</p>
<p>prot参数指定了映射存储区的保护要求，可将prot参数指定为PROT_NONE，也可指PROT_READ、PROT_WRITE和PROT_EXEC的任意组合的按位或。对指定映射存储区的保护要求不能超过文件open模式访问权限。例如，若该文件是只读打开的，那么对映射存储区就不能指定PROT_WRITE。</p>
<pre><code>注意：子进程能通过fork继承存储映射区（因为子进程复制父进程地址空间，而存储映射区是该地址空间中的一部分），但是由于同样的原因，新程序则不能通过exec继承存储映射区。
调用mprotect可以更改一个现有映射的权限。
</code></pre>

	
	</div>
  <a type="button" href="/2021/09/02/高级IO/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/08/30/守护进程/" >Unix守护进程</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-08-30  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/08/30/守护进程/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<p>系统进程依赖于操作系统实现。父进程ID为0的各进程通常是内核进程，它们作为系统引导装入过程的一部分而启动。（init是个例外，它是一个由内核在引导装入时启动的用户层次的命令。）内核进程是特殊的，通常存在于系统的整个生命期中。它们以超级用户特权运行，无控制终端，无命令行。<br>在ps的输出实例中，内核守护进程的名字出现在方括号中。该版本的Linux使用一个名为kthreadd的特殊内核进程来创建其他内核进程，所以kthreadd表现为其他内核进程的父进程。对于需要在进程上下文执行工作但却不被用户层进程上下文调用的每一个内核组件，通常有它自己的内核守护进程。例如，在Linux中：kswapd守护进程也称为内存换页守护进程。它支持虚拟内存子系统在经过一段时间后将脏页面慢慢地写回磁盘来回收这些页面。</p>
<p>flush守护进程在可用内存达到设置的最小阈值时将脏页面冲洗至磁盘。它也定期地将脏页面冲洗回磁盘来减少在系统出现故障时发生的数据丢失。多个冲洗守护进程可以同时存在，每个写回的设备都有一个冲洗守护进程。输出实例中显示出一个名为flush-8:0的冲洗守护进程。从名字中可以看出，写回设备是通过主设备号（8）和副设备号（0）来识别的。</p>
<p>sync_supers守护进程定期将文件系统元数据冲洗至磁盘。</p>
<p>jbd守护进程帮助实现了ext4文件系统中的日志功能。<br>进程1通常是init（Mac OS X中是launchd<br>），8.2节对此做过说明。它是一个系统守护进程，除了其他工作外，主要负责启动各运行层次特定的系统服务。这些服务通常是在它们自己拥有的守护进程的帮助下实现的。</p>
<p>rpcbind守护进程提供将远程过程调用（Remote Procedure Call，RPC）程序号映射为网络端口号的服务。rsyslogd<br>守护进程可以被由管理员启用的将系统消息记入日志的任何程序使用。可以在一台实际的控制台上打印这些消息，也可将它们写到一个文件中。（13.4节将对syslog<br>设施进行说明。）</p>
<p>inetd守护进程。它侦听系统网络接口，以便取得来自网络的对各种网络服务进程的请求。nfsd、nfsiod、lockd、rpciod、rpc.idmapd、rpc.statd和rpc.mountd守护进程提供对网络文件系统（Network File System，NFS）的支持。注意，前4个是内核守护进程，后3个是用户级守护进程。</p>
<p>cron守护进程在定期安排的日期和时间执行命令。许多系统管理任务是通过cron<br>每隔一段固定的时间就运行相关程序而得以实现的。atd守护进程与cron<br>类似，它允许用户在指定的时间执行任务，但是每个任务它只执行一次，而非在定期安排的时间反复执行。cupsd守护进程是个打印假脱机进程，它处理对系统提出的各个打印请求。sshd<br>守护进程提供了安全的远程登录和执行设施。</p>
<h2 id="守护进程的编程规则"><a href="#守护进程的编程规则" class="headerlink" title="守护进程的编程规则"></a>守护进程的编程规则</h2><p>在编写守护进程程序时需遵循一些基本规则，以防止产生不必要的交互作用。</p>
<p>（1）首先要做的是调用umask将文件模式创建屏蔽字设置为一个已知值（通常是0）。由继承得来的文件模式创建屏蔽字可能会被设置为拒绝某些权限。如果守护进程要创建文件，那么它可能要设置特定的权限。例如，若守护进程要创建组可读、组可写的文件，继承的文件模式创建屏蔽字可能会屏蔽上述两种权限中的一种，而使其无法发挥作用。另一方面，如果守护进程调用的库函数创建了文件，那么将文件模式创建屏蔽字设置为一个限制性更强的值（如007）可能会更明智，因为库函数可能不允许调用者通过一个显式的函数参数来设置权限。</p>
<p>（2）调用fork，然后使父进程exit。这样做实现了下面几点。第一，如果（1）首先要做的是调用umask将文件模式创建屏蔽字设置为一个已知值（通常是0）。由继承得来的文件模式创建屏蔽字可能会被设置为拒绝某些权限。如果守护进程要创建文件，那么它可能要设置特定的权限。例如，若守护进程要创建组可读、组可写的文件，继承的文件模式创建屏蔽字可能会屏蔽上述两种权限中的一种，而使其无法发挥作用。另一方面，如果守护进程调用的库函数创建了文件，那么将文件模式创建屏蔽字设置为一个限制性更强的值（如007）可能会更明智，因为库函数可能不允许调用者通过一个显式的函数参数来设置权限。</p>
<p>（3）调用setsid创建一个新会话。然后执行9.5节中列出的3个步骤，使调用进程：（a）成为新会话的首进程，（b）成为一个新进程组的组长进程，（c）没有控制终端。</p>
<pre><code>在基于System V的系统中，有些人建议在此时再次调用fork，终止父进程，继续使用子进程中的守护进程。这就保证了该守护进程不是会话首进程，于是按照System V规则,可以防止它取得控制终端。为了避免取得控制终端的另一种方法是，无论何时打开一个终端设备，都一定要指定O_NOCTTY。
</code></pre>
<p>（4）将当前工作目录更改为根目录。从父进程处继承过来的当前工作目录可能在一个挂载的文件系统中。因为守护进程通常在系统再引导之前是一直存在的，所以如果守护进程的当前工作目录在一个挂载文件系统中，那么该文件系统就不能被卸载。或者，某些守护进程还可能会把当前工作目录更改到某个指定位置，并在此位置进行它们的全部工作。例如，行式打印机假脱机守护进程就可能将其工作目录更改到它们的spool目录上。</p>
<p>（5）关闭不再需要的文件描述符。这使守护进程不再持有从其父进程继承来的任何文件描符（父进程可能是shell进程，或某个其他进程）。可以使用open_max函数（见2.17节）或getrlimit函数（见7.11节）来判定最高文件描述符值，并关闭直到该值的所有描述符。</p>
<p>（6）某些守护进程打开/dev/null使其具有文件描述符0、1和2，这样，任何一个试图读标准输入、写标准输出或标准错误的库例程都不会产生任何效果。因为守护进程并不与终端设备相关联，所以其输出无处显示，也无处从交互式用户那里接收输入。即使守护进程是从交互式会话启动的，但是守护进程是在后台运行的，所以登录会话的终止并不影响守护进程。如果其他用户在同一终端设备上登录，我们不希望在该终端上见到守护进程的输出，用户也不期望他们在终端上的输入被守护进程读取。</p>
<h2 id="出错记录"><a href="#出错记录" class="headerlink" title="出错记录"></a>出错记录</h2><p>守护进程存在的一个问题是如何处理出错消息。因为它本就不应该有控制终端，所以不能只是简单地写到标准错误上。我们不希望所有守护进程都写到控制台设备上，因为在很多工作站上控制台设备都运行着一个窗口系统。我们也不希望每个守护进程将它自己的出错消息写到一个单独的文件中。对任何一个系统管理人员而言，如果要关心哪一个守护进程写到哪一个记录文件中，并定期地检查这些文件，那么一定会使他感到头痛。所以，需要有一个集中的守护进程出错记录设施。</p>
<p>有以下3种产生日志消息的方法。<br>（1）内核例程可以调用 log 函数。任何一个用户进程都可以通过打开（open）并读取（read）/dev/klog设备来读取这些消息。因为我们无意编写内核例程，所以不再进一步说明此函数。</p>
<p>（2）大多数用户进程（守护进程）调用syslog(3)函数来产生日志消息。我们将在下面说明其调用序列。这使消息被发送至UNIX域数据报套接字/dev/log。</p>
<p>（3）无论一个用户进程是在此主机上，还是在通过TCP/IP网络连接到此主机的其他主机上，都可将日志消息发向UDP端口514。注意，syslog函数从不产生这些UDP数据报，它们要求产生此日志消息的进程进行显式的网络编程。</p>
<p>关于UNIX域套接字以及UDP套接字的细节，请参阅Stevens、Fenner和Rudoff[2004]。<br>通常，syslogd守护进程读取所有3种格式的日志消息。此守护进程在启动时读一个配置文件，其文件名一般为/etc/syslog.conf，该文件决定了不同种类的消息应送向何处。例如，紧急消息可发送至系统管理员（若已登录），并在控制台上打印，而警告消息则可记录到一个文件中。</p>
<p>该设施的接口是syslog函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ident, <span class="keyword">int</span> option, <span class="keyword">int</span> facility)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> maskpri)</span></span>;</span><br></pre></td></tr></table></figure>

<p>调用openlog是可选择的。如果不调用openlog，则在第一次调用syslog时，自动调用openlog。调用closelog也是可选择的，因为它只是关闭曾被用于与syslogd守护进程进行通信的描述符。</p>
<p>调用openlog使我们可以指定一个ident，以后，此ident将被加至每则日志消息中。ident一般是程序的名称（如cron、inetd）。option参数是指定各种选项的位屏蔽。图13-3介绍了可用的option（选项）。若在Single UNIXSpecification的openlog定义中包括了该选项，则在XSI列中用一个黑点表示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">daemonize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, fd0, fd1, fd2;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span>　<span class="title">rl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>　<span class="title">sa</span>;</span></span><br><span class="line">  <span class="comment">/*      * Clear file creation mask.      */</span></span><br><span class="line">  <span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*      * Get maximum number of file descriptors.      */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getrlimit</span>(RLIMIT_NOFILE, &amp;rl) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">err_quit</span>(<span class="string">&quot;%s: can&#x27;t get file limit&quot;</span>, cmd);</span><br><span class="line">  <span class="comment">/*      * Become a session leader to lose controlling TTY.      */</span> <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">err_quit</span>(<span class="string">&quot;%s: can&#x27;t fork&quot;</span>, cmd);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) <span class="comment">/* parent */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setsid</span>();</span><br><span class="line">  <span class="comment">/*      * Ensure future opens won&#x27;t allocate controlling TTYs.      */</span></span><br><span class="line">  sa.sa_handler = SIG_IGN;</span><br><span class="line">  <span class="built_in">sigemptyset</span>(&amp;sa.sa_mask);</span><br><span class="line">  sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">sigaction</span>(SIGHUP, &amp;sa, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">err_quit</span>(<span class="string">&quot;%s: can&#x27;t ignore SIGHUP&quot;</span>, cmd);</span><br><span class="line"></span><br><span class="line">  　 <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">err_quit</span>(<span class="string">&quot;%s: can&#x27;t fork&quot;</span>, cmd);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) <span class="comment">/* parent */</span></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">/*      * Change the current working directory to the root so      * we won&#x27;t prevent file systems from being unmounted.      */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">err_quit</span>(<span class="string">&quot;%s: can&#x27;t change directory to /&quot;</span>, cmd);</span><br><span class="line">  <span class="comment">/*      * Close all open file descriptors.      */</span></span><br><span class="line">  <span class="keyword">if</span> (rl.rlim_max == RLIM_INFINITY)</span><br><span class="line">    rl.rlim_max = <span class="number">1024</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rl.rlim_max; i++)</span><br><span class="line">    <span class="built_in">close</span>(i);</span><br><span class="line">  <span class="comment">/*      * Attach file descriptors 0, 1, and 2 to /dev/null.      */</span></span><br><span class="line">  fd0 = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">  fd1 = <span class="built_in">dup</span>(<span class="number">0</span>);</span><br><span class="line">  fd2 = <span class="built_in">dup</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">/*      * Initialize the log file.      */</span></span><br><span class="line">  <span class="built_in">openlog</span>(cmd, LOG_CONS, LOG_DAEMON);</span><br><span class="line">  <span class="keyword">if</span> (fd0 != <span class="number">0</span> || fd1 != <span class="number">1</span> || fd2 != <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;unexpected file descriptors %d %d %d&quot;</span>, fd0, fd1, fd2);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单实例守护进程"><a href="#单实例守护进程" class="headerlink" title="单实例守护进程"></a>单实例守护进程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCKFILE <span class="meta-string">&quot;/var/run/daemon.pid&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCKMODE (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">lockfile</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">already_running</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>    fd;</span><br><span class="line">    <span class="keyword">char</span>    buf[<span class="number">16</span>];</span><br><span class="line">    fd = <span class="built_in">open</span>(LOCKFILE, O_RDWR | O_CREAT, LOCKMODE);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;can&#x27;t open %s: %s&quot;</span>, LOCKFILE, <span class="built_in">strerror</span>(errno));</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">lockfile</span>(fd) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">if</span> (errno == EACCES || errno == EAGAIN)</span><br><span class="line">         &#123;</span><br><span class="line">              <span class="built_in">close</span>(fd);</span><br><span class="line">              <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">          </span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;can&#x27;t lock %s: %s&quot;</span>, LOCKFILE, <span class="built_in">strerror</span>(errno));</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ftruncate</span>(fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%ld&quot;</span>, (<span class="keyword">long</span>)<span class="built_in">getpid</span>());</span><br><span class="line">    <span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2021/08/30/守护进程/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/08/20/Android-Java类加载机制/" >Java类加载机制</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-08-20  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/08/20/Android-Java类加载机制/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="JVM的类加载器包括3种"><a href="#JVM的类加载器包括3种" class="headerlink" title="JVM的类加载器包括3种"></a>JVM的类加载器包括3种</h2><p>　　1）Bootstrap ClassLoader（引导类加载器）</p>
<p>　　C/C++代码实现的加载器，用于加载指定的JDK的核心类库，比如java.lang.、java.uti.等这些系统类。Java虚拟机的启动就是通过Bootstrap ，该Classloader在java里无法获取，负责加载/lib下的类。<br>　　2）Extensions ClassLoader（拓展类加载器）</p>
<p>　　Java中的实现类为ExtClassLoader，提供了除了系统类之外的额外功能，可以在java里获取，负责加载/lib/ext下的类。<br>　　3）Application ClassLoader（应用程序类加载器）</p>
<p>　　Java中的实现类为AppClassLoader，是与我们接触对多的类加载器，开发人员写的代码默认就是由它来加载，ClassLoader.getSystemClassLoader返回的就是它。</p>
<p>也可以自定义类加载器，只需要通过继承java.lang.ClassLoader类的方式来实现自己的类加载器即可。</p>
<p>加载顺序：</p>
<ol>
<li>Bootstrap CLassloder</li>
<li>Extention ClassLoader</li>
<li>AppClassLoader</li>
</ol>
<p>双亲委派机制：</p>
<p>双亲委派模式的工作原理的是;如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都不愿意干活，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成，这个就是双亲委派。</p>
<p>why：</p>
<p>1）避免重复加载，如果已经加载过一次Class，可以直接读取已经加载的Class</p>
<p>2）更加安全，无法自定义类来替代系统的类，可以防止核心API库被随意篡改</p>
<p>类加载的时机：</p>
<p>1、隐式加载：</p>
<pre><code>创建类的实例
访问类的静态变量，或者为静态变量赋值
调用类的静态方法
使用反射方式来强制创建某个类或接口对应的java.lang.Class对象
初始化某个类的子类
</code></pre>
<p>2、显示加载：两者又有所区别</p>
<pre><code>使用LoadClass（）加载
使用forName（）加载
</code></pre>
<p>1、装载：查找和导入Class文件</p>
<p>2、链接：其中解析步骤是可以选择的</p>
<pre><code>（a）检查：检查载入的class文件数据的正确性
（b）准备：给类的静态变量分配存储空间
（c）解析：将符号引用转成直接引用
</code></pre>
<p>3、初始化：即调用&lt;clinit&gt;函数，对静态变量，静态代码块执行初始化工作</p>
<h2 id="Android的类加载器"><a href="#Android的类加载器" class="headerlink" title="Android的类加载器"></a>Android的类加载器</h2><p>Android系统中与ClassLoader相关的一共有8个：</p>
<p>ClassLoader为抽象类；</p>
<p>BootClassLoader预加载常用类，单例模式。与Java中的BootClassLoader不同，它并不是由C/C++代码实现，而是由Java实现的；</p>
<p>BaseDexClassLoader是PathClassLoader、DexClassLoader、InMemoryDexClassLoader的父类，类加载的主要逻辑都是在BaseDexClassLoader完成的。</p>
<p>SecureClassLoader继承了抽象类ClassLoader，拓展了ClassLoader类加入了权限方面的功能，加强了安全性，其子类URLClassLoader是用URL路径从jar文件中加载类和资源。</p>
<p>其中重点关注的是PathClassLoader和DexClassLoader。</p>
<p>PathClassLoader是Android默认使用的类加载器，一个apk中的Activity等类便是在其中加载。</p>
<p>DexClassLoader可以加载任意目录下的dex/jar/apk/zip文件，比PathClassLoader更灵活，是实现插件化、热修复以及dex加壳的重点。</p>
<p>Android8.0新引入InMemoryDexClassLoader，从名字便可看出是用于直接从内存中加载dex。</p>

	
	</div>
  <a type="button" href="/2021/08/20/Android-Java类加载机制/#more" class="btn btn-default more">Read More</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">

   
    
           <a type="button" class="btn btn-default disabled"><i class="fa fa-arrow-circle-o-left"></i>Prev</a>
        

        <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
 
       <a href="/page/2/" type="button" class="btn btn-default ">Next<i class="fa fa-arrow-circle-o-right"></i></a>     
        

  
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/unix/">unix<span>2</span></a></li>
		
			<li><a href="/tags/算法与数据结构/">算法与数据结构<span>3</span></a></li>
		
			<li><a href="/tags/python/">python<span>2</span></a></li>
		
			<li><a href="/tags/漏洞分析/">漏洞分析<span>5</span></a></li>
		
			<li><a href="/tags/fuzzing/">fuzzing<span>1</span></a></li>
		
			<li><a href="/tags/正则表达式/">正则表达式<span>1</span></a></li>
		
			<li><a href="/tags/软件调试/">软件调试<span>2</span></a></li>
		
			<li><a href="/tags/ARM/">ARM<span>2</span></a></li>
		
			<li><a href="/tags/windows内核/">windows内核<span>5</span></a></li>
		
			<li><a href="/tags/符号执行/">符号执行<span>1</span></a></li>
		
			<li><a href="/tags/Android/">Android<span>1</span></a></li>
		
			<li><a href="/tags/CTF-Writeup/">CTF,Writeup<span>2</span></a></li>
		
			<li><a href="/tags/恶意代码分析/">恶意代码分析<span>1</span></a></li>
		
			<li><a href="/tags/CTF/">CTF<span>1</span></a></li>
		
			<li><a href="/tags/CPU/">CPU<span>4</span></a></li>
		
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2023/02/14/CPU乱序执行/" ><i class="fa fa-file-o"></i>CPU乱序执行</a>
      </li>
    
      <li>
        <a href="/2021/11/13/unicorn分析/" ><i class="fa fa-file-o"></i>unicorn分析</a>
      </li>
    
      <li>
        <a href="/2021/09/30/一个加密木马的分析/" ><i class="fa fa-file-o"></i>一个加密木马的分析</a>
      </li>
    
      <li>
        <a href="/2021/09/24/Windows系统调用/" ><i class="fa fa-file-o"></i>Windows系统调用</a>
      </li>
    
      <li>
        <a href="/2021/09/17/Windbg用法/" ><i class="fa fa-file-o"></i>Windbg用法</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/p1ain0" title="My Github account." target="_blank"]);">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2023 P1AIN0&#39;S BLOG
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
>



</body>
   </html>
