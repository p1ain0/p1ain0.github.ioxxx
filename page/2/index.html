<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Page 2 | P1AIN0&#39;S BLOG</title>
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="P1AIN0&#39;S BLOG"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="P1AIN0&#39;S BLOG" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  




<meta name="generator" content="Hexo 5.4.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">P1AIN0&#39;S BLOG</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header logo">
  <h1>P1AIN0&#39;S BLOG<span class="blink-fast">|</span></h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">

</div>    

		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/08/01/pwn总结/" >pwn总结</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-08-01  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
		
            
            <p class="post">&lt;h2 id=&#34;栈溢出&#34;&gt;&lt;a href=&#34;#栈溢出&#34; class=&#34;headerlink&#34; title=&#34;栈溢出&#34;&gt;&lt;/a&gt;栈溢出&lt;/h2&gt;&lt;h3 id=&#34;过NX&#34;&gt;&lt;a href=&#34;#过NX&#34; class=&#34;headerlink&#34; title=&#34;过NX&#34;&gt;&lt;/a&gt;过NX&lt;/h3&gt;&lt;p&gt;No-eXecute，表示不可执行，其原理是将数据所在的内存页标识为不可执行，如果程序产生溢出转入执行 shellcode 时，CPU 会抛出异常。&lt;/p&gt;
&lt;p&gt;在 Linux 中，当装载器将程序装载进内存空间后，将程序的 .text 段标记为可执行，而其余的数据段（.data、.bss 等）以及栈、堆均为不可执行。因此，传统利用方式中通过修改 GOT 来执行 shellcode 的方式不再可行。&lt;/p&gt;
&lt;p&gt;使用ROP，ret2libc&lt;/p&gt;
&lt;h3 id=&#34;过PIE，ASLR&#34;&gt;&lt;a href=&#34;#过PIE，ASLR&#34; class=&#34;headerlink&#34; title=&#34;过PIE，ASLR&#34;&gt;&lt;/a&gt;过PIE，ASLR&lt;/h3&gt;&lt;p&gt;地址空间布局随机化（ASLR），该技术虽然不是由 GCC 编译时提供的，但对 PIE 还是有影响。该技术旨在将程序的内存布局随机化，使得攻击者不能轻易地得到数据区的地址来构造 payload。由于程序的堆栈分配与共享库的装载都是在运行时进行，系统在程序每次执行时，随机地分配程序堆栈的地址以及共享库装载的地址。使得攻击者无法预测自己写入的数据区的虚拟地址。&lt;/p&gt;
&lt;p&gt;针对该保护机制的攻击，往往是通过信息泄漏来实现。由于同一模块中的所有代码和数据的相对偏移是固定的，攻击者只要泄漏出某个模块中的任一代码指针或数据指针，即可通过计算得到此模块中任意代码或数据的地址。&lt;/p&gt;
&lt;p&gt;PIE（Position Independent Executable）其实就是把可执行文件给编译成动态链接库，需要配合 ASLR 来使用，以达到可执行文件的加载时地址随机化。简单来说，PIE 是编译时随机化，由编译器完成；ASLR 是加载时随机化，由操作系统完成。ASLR 将程序运行时的堆栈以及共享库的加载地址随机化，而 PIE 在编译时将程序编译为位置无关、即程序运行时各个段加载的虚拟地址在装载时确定。开启 PIE 时，编译生成的是动态库文件（Shared object）文件，而关闭 PIE 后生成可执行文件（Executable）&lt;/p&gt;
&lt;p&gt;需要把地址泄漏出来&lt;/p&gt;
&lt;h3 id=&#34;过canary&#34;&gt;&lt;a href=&#34;#过canary&#34; class=&#34;headerlink&#34; title=&#34;过canary&#34;&gt;&lt;/a&gt;过canary&lt;/h3&gt;&lt;p&gt;-fno-stack-protector 关闭canary检测&lt;br&gt;-fstack-protector 打开canary检测&lt;/p&gt;
&lt;p&gt;通过泄漏地址或者&lt;/p&gt;
&lt;h3 id=&#34;RELRO&#34;&gt;&lt;a href=&#34;#RELRO&#34; class=&#34;headerlink&#34; title=&#34;RELRO&#34;&gt;&lt;/a&gt;RELRO&lt;/h3&gt;&lt;p&gt;RELRO（ReLocation Read-Only）设置符号重定向表为只读或在程序启动时就解析并绑定所有动态符号，从而减少对 GOT（Global Offset Table）的攻击。&lt;/p&gt;
&lt;p&gt;RELOR 有两种形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Partial RELRO：一些段（包括 &lt;code&gt;.dynamic&lt;/code&gt;）在初始化后将会被标记为只读。&lt;/li&gt;
&lt;li&gt;Full RELRO：除了 Partial RELRO，延迟绑定将被禁止，所有的导入符号将在开始时被解析，&lt;code&gt;.got.plt&lt;/code&gt; 段会被完全初始化为目标函数的最终地址，并被标记为只读。另外 &lt;code&gt;link_map&lt;/code&gt; 和 &lt;code&gt;_dl_runtime_resolve&lt;/code&gt; 的地址也不会被装入。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编译参数&#34;&gt;&lt;a href=&#34;#编译参数&#34; class=&#34;headerlink&#34; title=&#34;编译参数&#34;&gt;&lt;/a&gt;编译参数&lt;/h2&gt;&lt;p&gt;各种安全技术的编译参数如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;安全技术&lt;/th&gt;
&lt;th&gt;完全开启&lt;/th&gt;
&lt;th&gt;部分开启&lt;/th&gt;
&lt;th&gt;关闭&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Canary&lt;/td&gt;
&lt;td&gt;-fstack-protector-all&lt;/td&gt;
&lt;td&gt;-fstack-protector&lt;/td&gt;
&lt;td&gt;-fno-stack-protector&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NX&lt;/td&gt;
&lt;td&gt;-z noexecstack&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-z execstack&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PIE&lt;/td&gt;
&lt;td&gt;-pie&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-no-pie&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RELRO&lt;/td&gt;
&lt;td&gt;-z now&lt;/td&gt;
&lt;td&gt;-z lazy&lt;/td&gt;
&lt;td&gt;-z norelro&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
<p>
		

	

	</div>
  <a type="button" href="/2021/08/01/pwn总结/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><h3 id="过NX"><a href="#过NX" class="headerlink" title="过NX"></a>过NX</h3><p>No-eXecute，表示不可执行，其原理是将数据所在的内存页标识为不可执行，如果程序产生溢出转入执行 shellcode 时，CPU 会抛出异常。</p>
<p>在 Linux 中，当装载器将程序装载进内存空间后，将程序的 .text 段标记为可执行，而其余的数据段（.data、.bss 等）以及栈、堆均为不可执行。因此，传统利用方式中通过修改 GOT 来执行 shellcode 的方式不再可行。</p>
<p>使用ROP，ret2libc</p>
<h3 id="过PIE，ASLR"><a href="#过PIE，ASLR" class="headerlink" title="过PIE，ASLR"></a>过PIE，ASLR</h3><p>地址空间布局随机化（ASLR），该技术虽然不是由 GCC 编译时提供的，但对 PIE 还是有影响。该技术旨在将程序的内存布局随机化，使得攻击者不能轻易地得到数据区的地址来构造 payload。由于程序的堆栈分配与共享库的装载都是在运行时进行，系统在程序每次执行时，随机地分配程序堆栈的地址以及共享库装载的地址。使得攻击者无法预测自己写入的数据区的虚拟地址。</p>
<p>针对该保护机制的攻击，往往是通过信息泄漏来实现。由于同一模块中的所有代码和数据的相对偏移是固定的，攻击者只要泄漏出某个模块中的任一代码指针或数据指针，即可通过计算得到此模块中任意代码或数据的地址。</p>
<p>PIE（Position Independent Executable）其实就是把可执行文件给编译成动态链接库，需要配合 ASLR 来使用，以达到可执行文件的加载时地址随机化。简单来说，PIE 是编译时随机化，由编译器完成；ASLR 是加载时随机化，由操作系统完成。ASLR 将程序运行时的堆栈以及共享库的加载地址随机化，而 PIE 在编译时将程序编译为位置无关、即程序运行时各个段加载的虚拟地址在装载时确定。开启 PIE 时，编译生成的是动态库文件（Shared object）文件，而关闭 PIE 后生成可执行文件（Executable）</p>
<p>需要把地址泄漏出来</p>
<h3 id="过canary"><a href="#过canary" class="headerlink" title="过canary"></a>过canary</h3><p>-fno-stack-protector 关闭canary检测<br>-fstack-protector 打开canary检测</p>
<p>通过泄漏地址或者</p>
<h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><p>RELRO（ReLocation Read-Only）设置符号重定向表为只读或在程序启动时就解析并绑定所有动态符号，从而减少对 GOT（Global Offset Table）的攻击。</p>
<p>RELOR 有两种形式：</p>
<ul>
<li>Partial RELRO：一些段（包括 <code>.dynamic</code>）在初始化后将会被标记为只读。</li>
<li>Full RELRO：除了 Partial RELRO，延迟绑定将被禁止，所有的导入符号将在开始时被解析，<code>.got.plt</code> 段会被完全初始化为目标函数的最终地址，并被标记为只读。另外 <code>link_map</code> 和 <code>_dl_runtime_resolve</code> 的地址也不会被装入。</li>
</ul>
<h2 id="编译参数"><a href="#编译参数" class="headerlink" title="编译参数"></a>编译参数</h2><p>各种安全技术的编译参数如下：</p>
<table>
<thead>
<tr>
<th>安全技术</th>
<th>完全开启</th>
<th>部分开启</th>
<th>关闭</th>
</tr>
</thead>
<tbody><tr>
<td>Canary</td>
<td>-fstack-protector-all</td>
<td>-fstack-protector</td>
<td>-fno-stack-protector</td>
</tr>
<tr>
<td>NX</td>
<td>-z noexecstack</td>
<td></td>
<td>-z execstack</td>
</tr>
<tr>
<td>PIE</td>
<td>-pie</td>
<td></td>
<td>-no-pie</td>
</tr>
<tr>
<td>RELRO</td>
<td>-z now</td>
<td>-z lazy</td>
<td>-z norelro</td>
</tr>
</tbody></table>

	
	</div>
  <a type="button" href="/2021/08/01/pwn总结/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/07/23/x64内核研究(IA-32e模式)/" >x64内核研究（IA-32e模式）</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-07-23  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
		
            
            <p class="post">&lt;h2 id=&#34;IA-32e模式&#34;&gt;&lt;a href=&#34;#IA-32e模式&#34; class=&#34;headerlink&#34; title=&#34;IA-32e模式&#34;&gt;&lt;/a&gt;IA-32e模式&lt;/h2&gt;&lt;p&gt;IA-32e模式：内核64位，用户64位或32位 强制平坦段，不支持任务切换…&lt;/p&gt;
&lt;p&gt;Legacy模式：内核32位，用户32位支持非平坦段，任务切换，虚拟8086，实模式等。&lt;/p&gt;
&lt;p&gt;IA-32e: 代码段，数据段仍使用64位描述符，强制平坦(FS，GS除外)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.TSS段描述符扩展到128位
2.TSS段不用来任务切换，主要保存一堆rsp备用指针
3.中断门描述符扩展到128位
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;IA32_EFER MSR C0000080H&lt;/p&gt;
&lt;p&gt;IA32_FS_BASE C0000100H&lt;/p&gt;
&lt;p&gt;IA32_GS_BASE C0000101H&lt;/p&gt;
&lt;p&gt;IA32_KERNEl_GS_BASE C0000102H&lt;/p&gt;
&lt;p&gt;权限切换&lt;/p&gt;
&lt;p&gt;系统切换：只使用一张SSDT表，x64用户程序通过syscall进入内核 x86用户程序在ring3转入x64模式再进入内核&lt;/p&gt;
&lt;p&gt;中断：只使用一张idt表，内核可以根据栈上的保存的cs判断先前模式&lt;/p&gt;
&lt;h2 id=&#34;SMAP-和-SMEP&#34;&gt;&lt;a href=&#34;#SMAP-和-SMEP&#34; class=&#34;headerlink&#34; title=&#34;SMAP 和 SMEP&#34;&gt;&lt;/a&gt;SMAP 和 SMEP&lt;/h2&gt;&lt;p&gt;SMAP(Supervisor Mode Access Prevention，管理模式访问保护)和SMEP(Supervisor Mode Execution Prevention，管理模式执行保护)的作用分别是禁止内核CPU访问用户空间的数据和执行用户空间的代码，并不会因为你权限高就能访问/执行低权限的资源，你的就是你的，我的就是我的，而之前零环权限就很牛逼了，你的就是我的，我的还是我的。&lt;/p&gt;
&lt;h2 id=&#34;分页&#34;&gt;&lt;a href=&#34;#分页&#34; class=&#34;headerlink&#34; title=&#34;分页&#34;&gt;&lt;/a&gt;分页&lt;/h2&gt;&lt;p&gt;四级页表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;PXE&lt;/th&gt;
&lt;th&gt;PPE&lt;/th&gt;
&lt;th&gt;PDE&lt;/th&gt;
&lt;th&gt;PTE&lt;/th&gt;
&lt;th&gt;物理页面&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;Patch-Guard&#34;&gt;&lt;a href=&#34;#Patch-Guard&#34; class=&#34;headerlink&#34; title=&#34;Patch Guard&#34;&gt;&lt;/a&gt;Patch Guard&lt;/h2&gt;&lt;p&gt;绝大部分 PG 检测基于context结构体；&lt;br&gt;context包括：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一小段自解密代码要用到的系统api指针
重要的api代码copy
INITKDBG节的copy，
要检测的目标地址，大小，chucksum构成的结构体数组
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;context大部分时间是加密的；&lt;/p&gt;
&lt;p&gt;context的数据来自与系统初始化时的最初数据；&lt;/p&gt;
&lt;p&gt;context的地址，作为系统线程，DPC等的参数，随着调度被传递；&lt;/p&gt;
&lt;p&gt;context的验证逻辑执行周期约为2min，但每次检测的目标区块随机；&lt;/p&gt;
&lt;p&gt;context采用接力的方式调度，自解密-&amp;gt;检测逻辑-&amp;gt;复制自身到新的context-&amp;gt;加密新的context-&amp;gt;销毁旧的context；&lt;/p&gt;
&lt;p&gt;context-&amp;gt;检测逻辑的调用源有随机性，在PG初始化1时决定。&lt;/p&gt;
&lt;p&gt;攻击手法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.静态补丁
2.VT实现 读/执行 分离
<p>
		

	

	</div>
  <a type="button" href="/2021/07/23/x64内核研究(IA-32e模式)/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="IA-32e模式"><a href="#IA-32e模式" class="headerlink" title="IA-32e模式"></a>IA-32e模式</h2><p>IA-32e模式：内核64位，用户64位或32位 强制平坦段，不支持任务切换…</p>
<p>Legacy模式：内核32位，用户32位支持非平坦段，任务切换，虚拟8086，实模式等。</p>
<p>IA-32e: 代码段，数据段仍使用64位描述符，强制平坦(FS，GS除外)</p>
<pre><code>1.TSS段描述符扩展到128位
2.TSS段不用来任务切换，主要保存一堆rsp备用指针
3.中断门描述符扩展到128位
</code></pre>
<p>IA32_EFER MSR C0000080H</p>
<p>IA32_FS_BASE C0000100H</p>
<p>IA32_GS_BASE C0000101H</p>
<p>IA32_KERNEl_GS_BASE C0000102H</p>
<p>权限切换</p>
<p>系统切换：只使用一张SSDT表，x64用户程序通过syscall进入内核 x86用户程序在ring3转入x64模式再进入内核</p>
<p>中断：只使用一张idt表，内核可以根据栈上的保存的cs判断先前模式</p>
<h2 id="SMAP-和-SMEP"><a href="#SMAP-和-SMEP" class="headerlink" title="SMAP 和 SMEP"></a>SMAP 和 SMEP</h2><p>SMAP(Supervisor Mode Access Prevention，管理模式访问保护)和SMEP(Supervisor Mode Execution Prevention，管理模式执行保护)的作用分别是禁止内核CPU访问用户空间的数据和执行用户空间的代码，并不会因为你权限高就能访问/执行低权限的资源，你的就是你的，我的就是我的，而之前零环权限就很牛逼了，你的就是我的，我的还是我的。</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>四级页表</p>
<table>
<thead>
<tr>
<th>PXE</th>
<th>PPE</th>
<th>PDE</th>
<th>PTE</th>
<th>物理页面</th>
</tr>
</thead>
<tbody><tr>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>12</td>
</tr>
</tbody></table>
<h2 id="Patch-Guard"><a href="#Patch-Guard" class="headerlink" title="Patch Guard"></a>Patch Guard</h2><p>绝大部分 PG 检测基于context结构体；<br>context包括：</p>
<pre><code>一小段自解密代码要用到的系统api指针
重要的api代码copy
INITKDBG节的copy，
要检测的目标地址，大小，chucksum构成的结构体数组
...
</code></pre>
<p>context大部分时间是加密的；</p>
<p>context的数据来自与系统初始化时的最初数据；</p>
<p>context的地址，作为系统线程，DPC等的参数，随着调度被传递；</p>
<p>context的验证逻辑执行周期约为2min，但每次检测的目标区块随机；</p>
<p>context采用接力的方式调度，自解密-&gt;检测逻辑-&gt;复制自身到新的context-&gt;加密新的context-&gt;销毁旧的context；</p>
<p>context-&gt;检测逻辑的调用源有随机性，在PG初始化1时决定。</p>
<p>攻击手法：</p>
<pre><code>1.静态补丁
2.VT实现 读/执行 分离
3.定位所有的context调用源，针对性patch
4.基于加密算法分析，攻击context的内容
    (1) 搜索内存，粗筛context；
    (2)基于加密算法特征，定位context；
    (3)解密context，patch检测逻辑，加密写回context

5.设置context页面不可执行，接管页面异常处理
    (1)搜索内存，粗筛context；
    (2)hook PageFault，接管执行保护异常；
    (3)在异常处理中定位context，阻止检测逻辑。
</code></pre>

	
	</div>
  <a type="button" href="/2021/07/23/x64内核研究(IA-32e模式)/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/07/21/驱动的运行/" >驱动的运行</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-07-21  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/07/21/驱动的运行/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="cmd启动"><a href="#cmd启动" class="headerlink" title="cmd启动"></a>cmd启动</h2><p>注册驱动</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc create ServiceName binPath= &quot;C:\xxx.sys&quot; <span class="built_in">type</span>= kernel <span class="built_in">start</span>= demand</span><br></pre></td></tr></table></figure>

<p>sc create 表示创建一个服务， binPath 指驱动路径，type 表示驱动类型， start 表示启动类型。demand表示手动启动</p>
<p>启动服务</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc <span class="built_in">start</span> ServiceName</span><br></pre></td></tr></table></figure>

<p>停止服务</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc stop ServiceName</span><br></pre></td></tr></table></figure>

<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc delete ServiceName</span><br></pre></td></tr></table></figure>

<h2 id="API启动"><a href="#API启动" class="headerlink" title="API启动"></a>API启动</h2><h3 id="step1-打开服务管理器"><a href="#step1-打开服务管理器" class="headerlink" title="step1 打开服务管理器"></a>step1 打开服务管理器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SC_HANDLE <span class="title">OpenSCManagerA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpMachineName,     <span class="comment">//字符串常量，表示机器的名字，NULL表示打开的是本机的服务管理器。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpDatabaseName,    <span class="comment">//字符串常量，表示数据库的名字，NULL表示是一个活动数据库。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  dwDesiredAccess    <span class="comment">//DWORD类型的值，表示权限，SC_MANAGER_ALL_ACCESS (0xF003F)表示一切权限，SC_MANAGER_CREATE_SERVICE (0x0002)创建服务的权限，SC_MANAGER_ENUMERATE_SERVICE (0x0004)枚举服务的权限......</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个SC_HANDLE的句柄</span></span><br></pre></td></tr></table></figure>

<h3 id="step2-服务的注册"><a href="#step2-服务的注册" class="headerlink" title="step2 服务的注册"></a>step2 服务的注册</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SC_HANDLE <span class="title">CreateService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SC_HANDLE hSCManager,         <span class="comment">//服务管理器的句柄（必须具有SC_MANAGER_CREATE_SERVICE权限）</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpServiceName,      <span class="comment">//服务的名字，不能重名</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpDisplayName,      <span class="comment">//显示的名字</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwDesiredAccess,    <span class="comment">//服务的权限，SERVICE_START,SERVICE_STOP,SERVICE_QUERY_STATUS,SERVICE_ALL_ACCESS</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwServiceType,      <span class="comment">//表示创建何种服务服务的类型有 SERVICE_FILE_SYSTEM_DRIVER、SERVICE_KERNEL_DRIVER、SERVICE_WIN32_OWN_PROCESS、SERVICE_WIN32_SHARE_PROCESS</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwStartType,        <span class="comment">//服务的启动方式，SERVICE_BOOT_START（OS引导阶段启动的服务，由Winload模块负责）、SERVICE_SYSTEM_START（OS启动阶段启动的服务，由NT模块负责）、SERVICE_AUTO_START（OS启动完毕后启动的）、SERVICE_DEMAND_START（手动启动的服务）</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwErrorControl,     <span class="comment">//错误控制，具体指服务启动失败的情况下，操作系统需要执行何种操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpBinaryPathName,   <span class="comment">//可执行文件的全路径</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpLoadOrderGroup,   <span class="comment">//服务所在的分组名字NULL即可</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD   lpdwTagId,          <span class="comment">//与服务的加载顺序相关，0即可</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpDependencies,     <span class="comment">//表示该服务依赖的其他服务名的列表</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpServiceStartName, <span class="comment">//服务以什么用户身份启动，内核驱动设置为NULL即可</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpPassword          <span class="comment">//同lpServiceStartName</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>打开已注册的服务</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SC_HANDLE <span class="title">OpenService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SC_HANDLE hSCManager,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpServiceName,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwDesiredAccess</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="step3-启动服务"><a href="#step3-启动服务" class="headerlink" title="step3 启动服务"></a>step3 启动服务</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">StartService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SC_HANDLE hService,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwNumServiceArgs,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    *lpServiceArgVectors</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>停止暂停恢复服务：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ControlService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SC_HANDLE        hService,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD            dwControl,   <span class="comment">//SERVICE_CONTROL_PAUSE、SERVICE_CONTROL_STOP、SERVICE_CONTROL_CONTINUE......</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSERVICE_STATUS lpServiceStatus</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="step4-删除服务"><a href="#step4-删除服务" class="headerlink" title="step4 删除服务"></a>step4 删除服务</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeleteService</span><span class="params">(SC_HANDLE hService)</span></span></span><br></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2021/07/21/驱动的运行/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/07/13/afl/" >afl初探</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-07-13  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/07/13/afl/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="模糊测试六步骤"><a href="#模糊测试六步骤" class="headerlink" title="模糊测试六步骤"></a>模糊测试六步骤</h2><p>1.识别目标系统</p>
<p>2.确定输入</p>
<p>3.生成模糊数据</p>
<p>4.使用模糊数据进行测试</p>
<p>5.监控系统的行为</p>
<p>6.记录缺陷</p>
<h2 id="afl-fuzz"><a href="#afl-fuzz" class="headerlink" title="afl-fuzz"></a>afl-fuzz</h2><p>最近在研究afl-fuzz，发现一些有意思的东西，记录一下。</p>
<p>先说这个afl-fuzz的打桩机制，越想越觉得作者这人脑回路新奇。先说说使用这个方法的初衷。</p>
<p>为了提升性能，afl-fuzz使用了一个”fork server”，fuzz的进程只进行一次execve(), 连接(linking), 库初始化(libc initialization)。fuzz进程通过copy-on-write的方式从已停止的fuzz进程中clone下来。</p>
<p>为了实现copy-on-write功能，作者在编译的时候把初始化操作插入到程序的最开始，把编译后的程序拖到IDA会发现文件格式的DT_INIT_ARRAY里被添加了几个名字带有afl的函数，这几个函数会在程序加载完后先执行，（先于main函数），程序会在这里进行fork()子进程的操作。等待afl-fuzz的命令，接受子进程的状态，并发送给afl-fuzz。</p>

	
	</div>
  <a type="button" href="/2021/07/13/afl/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/07/06/散列/" >散列函数</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-07-06  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/07/06/散列/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="散列函数的优劣标准"><a href="#散列函数的优劣标准" class="headerlink" title="散列函数的优劣标准"></a>散列函数的优劣标准</h2><p>1.确定（dederminism）同一关键码总是被映射至同一地址。</p>
<p>2.快速（effciency）expeced - o(1)</p>
<p>3.满射（surjection）尽可能充分覆盖整个散列空间。</p>
<p>4.均匀（uniformity）关键码映射散列表各位置的概率尽量接近可有效避免聚集（clustering）现象。</p>
<h2 id="散列函数的选择"><a href="#散列函数的选择" class="headerlink" title="散列函数的选择"></a>散列函数的选择</h2><h3 id="整除取余法"><a href="#整除取余法" class="headerlink" title="整除取余法"></a>整除取余法</h3><h3 id="MAD法"><a href="#MAD法" class="headerlink" title="MAD法"></a>MAD法</h3><p>除余法的缺陷：</p>
<pre><code>1）不动点。无论表长取值如何，总有hash(0) = 0;
2）零阶均匀。[0,R)的关键码，平均分配至M个桶，但相邻关键码的散列必定相邻。
</code></pre>
<p>取M为素数：hash(key) = (a * key + b) % M</p>
<h3 id="平方取中"><a href="#平方取中" class="headerlink" title="平方取中"></a>平方取中</h3><p>取平方的中间若干位</p>
<h3 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h3><p>hash(123456789) = 123 + 456 + 789<br>hash(123456789) = 123 + 654 + 789</p>
<h3 id="位异或法"><a href="#位异或法" class="headerlink" title="位异或法"></a>位异或法</h3><p>hash(101011001) = 101 ^ 011 ^ 001</p>
<p>hash(101011001) = 101 ^ 110 ^ 001</p>
<h3 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a>伪随机数</h3><p>伪随机数发生器：rand(x+1) = [a * rand(x)] % M   //M是素数</p>
<p>rand(key) = [rand(0) * (a ** key)] % M</p>
<p>伪随机数发生器依赖于各个平台的具体实现，可移植性较差，慎用！！！</p>
<h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">hashcode</span><span class="params">(<span class="keyword">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        h = (h &lt;&lt; <span class="number">5</span>) | (h &gt;&gt; <span class="number">27</span>);</span><br><span class="line">        h += (<span class="keyword">int</span>)s[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">size_t</span>) h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冲突排解"><a href="#冲突排解" class="headerlink" title="冲突排解"></a>冲突排解</h2>
	
	</div>
  <a type="button" href="/2021/07/06/散列/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/07/05/CPU分页模式/" >分页模式开启</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-07-05  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/07/05/CPU分页模式/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h2><p>设置 CPU 的 CR0 的 PE 位为 1，这样就开启了 MMU。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov eax, PAGE_TLB_BADR ;页表物理地址</span><br><span class="line">mov cr3, eax</span><br><span class="line">;开启 保护模式和分页模式</span><br><span class="line">mov eax, cr0</span><br><span class="line">bts eax, 0 ;CR0.PE =1</span><br><span class="line">bts eax, 31 ;CR0.P = 1</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2021/07/05/CPU分页模式/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/07/05/CPU缓存/" >CPU缓存</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-07-05  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/07/05/CPU缓存/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h2><p>MESI 协议定义了 4 种基本状态：M、E、S、I，即修改（Modified）、独占（Exclusive）、共享（Shared）和无效（Invalid）。</p>
<p>1.M 修改（Modified）：当前 Cache 的内容有效，数据已经被修改而且与内存中的数据不一致，数据只在当前 Cache 里存在。</p>
<p>2.E 独占（Exclusive）：当前 Cache 中的内容有效，数据与内存中的数据一致，数据只在当前 Cache 里存在。</p>
<p>3.S 共享（Shared）：当前 Cache 中的内容有效，Cache 中的数据与内存中的数据一致，数据在多个 CPU 核心中的 Cache 里面存在。</p>
<p>4.无效（Invalid）：当前 Cache 无效。</p>
<p>Cache 硬件，它会监控所有 CPU 上 Cache 的操作，根据相应的操作使得 Cache 里的数据行在上面这些状态之间切换。Cache 硬件通过这些状态的变化，就能安全地控制各 Cache 间、各 Cache 与内存之间的数据一致性了。</p>
<h2 id="开启-Cache"><a href="#开启-Cache" class="headerlink" title="开启 Cache"></a>开启 Cache</h2><p>在 x86 CPU 上开启 Cache 非常简单，只需要将 CR0 寄存器中 CD、NW 位同时清 0 即可。CD=1 时表示 Cache 关闭，NW=1 时 CPU 不维护内存数据一致性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax, cr0</span><br><span class="line">;开启 CACHE    </span><br><span class="line">btr eax,29 ;CR0.NW=0</span><br><span class="line">btr eax,30  ;CR0.CD=0</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure>

<h2 id="获取内存视图"><a href="#获取内存视图" class="headerlink" title="获取内存视图"></a>获取内存视图</h2><p>给出一个物理地址并不能准确地定位到内存空间，内存空间只是映射物理地址空间中的一个子集，物理地址空间中可能有空洞，有 ROM，有内存，有显存，有 I/O 寄存器，所以获取内存有多大没用，关键是要获取哪些物理地址空间是可以读写的内存。</p>
<p>物理地址空间是由北桥芯片控制管理的，那我们是不是要找北桥要内存的地址空间呢？当然不是，在 x86 平台上还有更方便简单的办法，那就是 BIOS 提供的实模式下中断服务，就是 int 指令后面跟着一个常数的形式。由于 PC 机上电后由 BIOS 执行硬件初始化，中断向量表是 BIOS 设置的，所以执行中断自然执行 BIOS 服务。这个中断服务是 int 15h，但是它需要一些参数，就是在执行 int 15h 之前，对特定寄存器设置一些值，代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_getmemmap:  </span><br><span class="line">    xor ebx,ebx ;ebx设为0  </span><br><span class="line">    mov edi,E80MAP_ADR ;edi设为存放输出结果的1MB内的物理内存</span><br><span class="line">loop:  </span><br><span class="line">    mov eax,0e820h ;eax必须为0e820h  </span><br><span class="line">    mov ecx,20 ;输出结果数据项的大小为20字节：8字节内存基地址，8字节内存长度，4字节内存类型  </span><br><span class="line">    mov edx,0534d4150h ;edx必须为0534d4150h  </span><br><span class="line">    int 15h ;执行中断  </span><br><span class="line">    jc error ;如果flags寄存器的C位置1，则表示出错  </span><br><span class="line">    add edi,20;更新下一次输出结果的地址  </span><br><span class="line">    cmp ebx,0 ;如ebx为0，则表示循环迭代结束  </span><br><span class="line">    jne loop  ;还有结果项，继续迭代    </span><br><span class="line">    ret</span><br><span class="line">error:;出错处理</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_USABLE 1 <span class="comment">//可用内存</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_RESERV 2 <span class="comment">//保留内存不可使用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_ACPIREC 3 <span class="comment">//ACPI表相关的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_ACPINVS 4 <span class="comment">//ACPI NVS空间</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_AREACON 5 <span class="comment">//包含坏内存</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_e820</span>&#123;</span>    </span><br><span class="line">    <span class="keyword">u64_t</span> saddr;    <span class="comment">/* 内存开始地址 */</span>    </span><br><span class="line">    <span class="keyword">u64_t</span> lsize;    <span class="comment">/* 内存大小 */</span>    </span><br><span class="line">    <span class="keyword">u32_t</span> type;    <span class="comment">/* 内存类型 */</span></span><br><span class="line">&#125;<span class="keyword">e820map_t</span>;</span><br></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2021/07/05/CPU缓存/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/07/04/CPU工作模式/" >CPU实模式和保护模式</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-07-04  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
		
            
            <p class="post">&lt;h2 id=&#34;实模式&#34;&gt;&lt;a href=&#34;#实模式&#34; class=&#34;headerlink&#34; title=&#34;实模式&#34;&gt;&lt;/a&gt;实模式&lt;/h2&gt;&lt;p&gt;实模式又称实地址模式，对内存不加以任何的限制。&lt;/p&gt;
&lt;h3 id=&#34;实模式的寄存器&#34;&gt;&lt;a href=&#34;#实模式的寄存器&#34; class=&#34;headerlink&#34; title=&#34;实模式的寄存器&#34;&gt;&lt;/a&gt;实模式的寄存器&lt;/h3&gt;&lt;p&gt;x86CPU在实模式下的寄存器都是16位的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;寄存器&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;AX、BX、CX、DX、DI、SI、BP&lt;/td&gt;
&lt;td&gt;通用寄存器，里面可以存放数据、地址、参与运算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IP&lt;/td&gt;
&lt;td&gt;程序指针寄存器，始终指向下一条指令的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SP&lt;/td&gt;
&lt;td&gt;栈指针寄存器，始终指向当前栈顶&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CS、DS、ES、SS&lt;/td&gt;
&lt;td&gt;段寄存器，里面存放一个内存段的基地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FLAGS&lt;/td&gt;
&lt;td&gt;标志寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;实模式下访问内存&#34;&gt;&lt;a href=&#34;#实模式下访问内存&#34; class=&#34;headerlink&#34; title=&#34;实模式下访问内存&#34;&gt;&lt;/a&gt;实模式下访问内存&lt;/h3&gt;&lt;p&gt;实模式下所有的内存地址都是由段寄存器左移 4 位，再加上一个通用寄存器中的值或者常数形成地址，然后由这个地址去访问内存。&lt;/p&gt;
&lt;h3 id=&#34;实模式中断&#34;&gt;&lt;a href=&#34;#实模式中断&#34; class=&#34;headerlink&#34; title=&#34;实模式中断&#34;&gt;&lt;/a&gt;实模式中断&lt;/h3&gt;&lt;p&gt;中断即中止执行当前程序，转而跳转到另一个特定的地址上，去运行特定的代码。在实模式下它的实现过程是先保存 CS 和 IP 寄存器，然后装载新的 CS 和 IP 寄存器。&lt;/p&gt;
&lt;p&gt;通过IDTR查找中断向量表，根据中断号索引中断处理的地址。&lt;/p&gt;
&lt;h2 id=&#34;保护模式&#34;&gt;&lt;a href=&#34;#保护模式&#34; class=&#34;headerlink&#34; title=&#34;保护模式&#34;&gt;&lt;/a&gt;保护模式&lt;/h2&gt;&lt;h3 id=&#34;保护模式寄存器&#34;&gt;&lt;a href=&#34;#保护模式寄存器&#34; class=&#34;headerlink&#34; title=&#34;保护模式寄存器&#34;&gt;&lt;/a&gt;保护模式寄存器&lt;/h3&gt;&lt;p&gt;保护模式相比于实模式，增加了一些控制寄存器和段寄存器，扩展通用寄存器的位宽，所有的通用寄存器都是 32 位的，还可以单独使用低 16 位，这个低 16 位又可以拆分成两个 8 位寄存器，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;寄存器&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;EAX、EBX、ECX、EDX、EDI、ESI、EBP&lt;/td&gt;
&lt;td&gt;通用寄存器，里面可以存放数据、地址、参与运算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EIP&lt;/td&gt;
&lt;td&gt;程序指针寄存器，始终指向下一条指令的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
<p>
		

	

	</div>
  <a type="button" href="/2021/07/04/CPU工作模式/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h2><p>实模式又称实地址模式，对内存不加以任何的限制。</p>
<h3 id="实模式的寄存器"><a href="#实模式的寄存器" class="headerlink" title="实模式的寄存器"></a>实模式的寄存器</h3><p>x86CPU在实模式下的寄存器都是16位的。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AX、BX、CX、DX、DI、SI、BP</td>
<td>通用寄存器，里面可以存放数据、地址、参与运算</td>
</tr>
<tr>
<td>IP</td>
<td>程序指针寄存器，始终指向下一条指令的地址</td>
</tr>
<tr>
<td>SP</td>
<td>栈指针寄存器，始终指向当前栈顶</td>
</tr>
<tr>
<td>CS、DS、ES、SS</td>
<td>段寄存器，里面存放一个内存段的基地址</td>
</tr>
<tr>
<td>FLAGS</td>
<td>标志寄存器</td>
</tr>
</tbody></table>
<h3 id="实模式下访问内存"><a href="#实模式下访问内存" class="headerlink" title="实模式下访问内存"></a>实模式下访问内存</h3><p>实模式下所有的内存地址都是由段寄存器左移 4 位，再加上一个通用寄存器中的值或者常数形成地址，然后由这个地址去访问内存。</p>
<h3 id="实模式中断"><a href="#实模式中断" class="headerlink" title="实模式中断"></a>实模式中断</h3><p>中断即中止执行当前程序，转而跳转到另一个特定的地址上，去运行特定的代码。在实模式下它的实现过程是先保存 CS 和 IP 寄存器，然后装载新的 CS 和 IP 寄存器。</p>
<p>通过IDTR查找中断向量表，根据中断号索引中断处理的地址。</p>
<h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><h3 id="保护模式寄存器"><a href="#保护模式寄存器" class="headerlink" title="保护模式寄存器"></a>保护模式寄存器</h3><p>保护模式相比于实模式，增加了一些控制寄存器和段寄存器，扩展通用寄存器的位宽，所有的通用寄存器都是 32 位的，还可以单独使用低 16 位，这个低 16 位又可以拆分成两个 8 位寄存器，</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>EAX、EBX、ECX、EDX、EDI、ESI、EBP</td>
<td>通用寄存器，里面可以存放数据、地址、参与运算</td>
</tr>
<tr>
<td>EIP</td>
<td>程序指针寄存器，始终指向下一条指令的地址</td>
</tr>
<tr>
<td>ESP</td>
<td>栈指针寄存器，始终指向当前栈顶</td>
</tr>
<tr>
<td>CS、DS、ES、SS、FS、GS</td>
<td>段寄存器，里面存放一个内存段的基地址</td>
</tr>
<tr>
<td>EFLAGS</td>
<td>标志寄存器</td>
</tr>
<tr>
<td>CRO、CR1、CR2、CR3</td>
<td>CPU控制寄存器，控制CPU的功能特性</td>
</tr>
</tbody></table>
<h3 id="保护模式特权级"><a href="#保护模式特权级" class="headerlink" title="保护模式特权级"></a>保护模式特权级</h3><p>特权级分为4级R0～R3</p>
<h3 id="切换到保护模式"><a href="#切换到保护模式" class="headerlink" title="切换到保护模式"></a>切换到保护模式</h3><p>段描述符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq 0</span><br><span class="line">;第一个段描述符CPU硬件规定必须为0</span><br><span class="line">kcode_dsc: dq 0x00cf9e000000ffff</span><br><span class="line">;段基地址=0，段长度=0xfffff</span><br><span class="line">;G=1,D/B=1,L=0,AVL=0 </span><br><span class="line">;P=1,DPL=0,S=1</span><br><span class="line">;T=1,C=1,R=1,A=0</span><br><span class="line">kdata_dsc: dq 0x00cf92000000ffff</span><br><span class="line">;段基地址=0，段长度=0xfffff</span><br><span class="line">;G=1,D/B=1,L=0,AVL=0 </span><br><span class="line">;P=1,DPL=0,S=1</span><br><span class="line">;T=0,C=0,R=1,A=0</span><br><span class="line">GDT_END:</span><br><span class="line"></span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLEN  dw GDT_END-GDT_START-1</span><br><span class="line">GDTBASE  dd GDT_START</span><br></pre></td></tr></table></figure>

<p>1、准备全局段描述符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GDT_START:knull_dsc: dq 0kcode_dsc: dq 0x00cf9e000000ffffkdata_dsc: dq 0x00cf92000000ffffGDT_END:GDT_PTR:GDTLEN  dw GDT_END-GDT_START-1GDTBASE  dd GDT_START</span><br></pre></td></tr></table></figure>

<p>2、加载gdtr寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt [GDT_PTR]</span><br></pre></td></tr></table></figure>

<p>3、设置 CR0 寄存器，开启保护模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;开启 PE</span><br><span class="line">mov eax, cr0</span><br><span class="line">bts eax, 0                      ; CR0.PE =1</span><br><span class="line">mov cr0, eax         </span><br></pre></td></tr></table></figure>

<p>4、进行长跳转，加载 CS 段寄存器，即段选择子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp dword 0x8 :_32bits_mode ;_32bits_mode为32位代码标号即段偏移</span><br></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2021/07/04/CPU工作模式/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/07/03/Firefox漏洞研究/" >Firefox漏洞研究</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-07-03  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/07/03/Firefox漏洞研究/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<p>(PS:长期更新)</p>

	
	</div>
  <a type="button" href="/2021/07/03/Firefox漏洞研究/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/07/03/一道有意思的pwn题目/" >记一道有意思的ctf题目</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-07-03  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/07/03/一道有意思的pwn题目/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<p>原题目是pwnable.tw上边的calc，数组越界读写类的题目，</p>
<p>解题过程：首先通过越界读和printf把ebp泄漏出来，可以得到栈地址的信息，然后将rop写到retaddr处，利用ROPgadget寻找rop的地址，利用泄漏的栈地址计算当前栈的位置，把”/bin/sh”写到栈空间上的地址，也写到rop链中，并利用pop ebx,把地址保存到ebx中。实现 int 0x80系统调用。</p>
<p>(PS:漏洞利用点是看网上大神的题解才知道的)</p>

	
	</div>
  <a type="button" href="/2021/07/03/一道有意思的pwn题目/#more" class="btn btn-default more">Read More</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">

   
    
     <a href="/" type="button" class="btn btn-default"><i class="fa fa-arrow-circle-o-left"></i> Prev</a>
      

        <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
 
       <a href="/page/3/" type="button" class="btn btn-default ">Next<i class="fa fa-arrow-circle-o-right"></i></a>     
        

  
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/windows内核/">windows内核<span>4</span></a></li>
		
			<li><a href="/tags/算法与数据结构/">算法与数据结构<span>3</span></a></li>
		
			<li><a href="/tags/漏洞研究/">漏洞研究<span>1</span></a></li>
		
			<li><a href="/tags/python/">python<span>2</span></a></li>
		
			<li><a href="/tags/CPU/">CPU<span>3</span></a></li>
		
			<li><a href="/tags/unix/">unix<span>2</span></a></li>
		
			<li><a href="/tags/漏洞分析/">漏洞分析<span>6</span></a></li>
		
			<li><a href="/tags/符号执行/">符号执行<span>1</span></a></li>
		
			<li><a href="/tags/CTF-Writeup/">CTF,Writeup<span>2</span></a></li>
		
			<li><a href="/tags/软件调试/">软件调试<span>1</span></a></li>
		
			<li><a href="/tags/正则表达式/">正则表达式<span>1</span></a></li>
		
			<li><a href="/tags/Android/">Android<span>1</span></a></li>
		
			<li><a href="/tags/CTF/">CTF<span>1</span></a></li>
		
			<li><a href="/tags/fuzzing/">fuzzing<span>1</span></a></li>
		
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2021/09/17/Windbg用法/" ><i class="fa fa-file-o"></i>Windbg用法</a>
      </li>
    
      <li>
        <a href="/2021/09/09/遇到hexo莫名其妙的bug/" ><i class="fa fa-file-o"></i>遇到hexo莫名其妙的bug</a>
      </li>
    
      <li>
        <a href="/2021/09/07/CVE-2021-3156分析/" ><i class="fa fa-file-o"></i>2021-08-04-CVE-2021-3156分析</a>
      </li>
    
      <li>
        <a href="/2021/09/02/高级IO/" ><i class="fa fa-file-o"></i>高级I/O</a>
      </li>
    
      <li>
        <a href="/2021/08/30/守护进程/" ><i class="fa fa-file-o"></i>Unix守护进程</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/p1ain0" title="My Github account." target="_blank"]);">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2021 P1AIN0&#39;S BLOG
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
