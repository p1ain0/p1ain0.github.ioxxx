<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Page 2 | P1AIN0&#39;S BLOG</title>
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="P1AIN0&#39;S BLOG"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="P1AIN0&#39;S BLOG" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  




<meta name="generator" content="Hexo 5.4.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">P1AIN0&#39;S BLOG</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header logo">
  <h1>P1AIN0&#39;S BLOG<span class="blink-fast">|</span></h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">

</div>    

		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/08/11/Arm Instractions/" >ARM-Instractions</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-08-11  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
		
            
            <p class="post">&lt;h2 id=&#34;DATA-Types&#34;&gt;&lt;a href=&#34;#DATA-Types&#34; class=&#34;headerlink&#34; title=&#34;DATA Types&#34;&gt;&lt;/a&gt;DATA Types&lt;/h2&gt;&lt;p&gt;与高级语言相似，ARM支持操作不同类型的数据类型。我们可以load（or stroe）的数据类型有signed and unsigned words、halfwords、or bytes. 这些数据类型的extensions分别是：halfwords是-h or -sh，bytes是-b or -sb，word没有extension. signed and unsinged 数据的区别：&lt;br&gt;    1.signed data type 能储存正数和负数，因此范围较小&lt;br&gt;    2.unsigned data type 可以保存大的正值（包括“零”），但不能保存负值，因此范围更广。&lt;/p&gt;
&lt;p&gt;以下是一些load和store指令的操作指令的一些例子：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;ldr = Load Word&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ldrh = Load &lt;span class=&#34;keyword&#34;&gt;unsigned&lt;/span&gt; Half Word&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ldrsh = Load &lt;span class=&#34;keyword&#34;&gt;signed&lt;/span&gt; Half Word&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ldrb = Load &lt;span class=&#34;keyword&#34;&gt;unsigned&lt;/span&gt; Byte&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ldrsb = Load &lt;span class=&#34;keyword&#34;&gt;signed&lt;/span&gt; Bytes&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;str = Store Word&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;strh = Store &lt;span class=&#34;keyword&#34;&gt;unsigned&lt;/span&gt; Half Word&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;strsh = Store &lt;span class=&#34;keyword&#34;&gt;signed&lt;/span&gt; Half Word&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;strb = Store &lt;span class=&#34;keyword&#34;&gt;unsigned&lt;/span&gt; Byte&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;strsb = Store &lt;span class=&#34;keyword&#34;&gt;signed&lt;/span&gt; Byte&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;查看内存中的字节有两种基本方式：Little-Endian (LE) 或 Big-Endian (BE)。 区别在于对象的每个字节存储在内存中的字节顺序。 在像 Intel x86 这样的小端机器上，最低有效字节存储在最低地址（最接近零的地址）。 在 big-endian 机器上，最高有效字节存储在最低地址。 ARM 体系结构在第 3 版之前是小端的，从那时起它是双端的，这意味着它具有允许可切换的端的设置。 例如，在 ARMv6 上，指令是固定的 little-endian，数据访问可以是 little-endian 或 big-endian，由程序状态寄存器 (CPSR) 的第 9 位（E 位）控制。&lt;/p&gt;
&lt;p&gt;寄存器的数量是依赖于ARM的版本的，通过查询ARM Reference Manual，除了基于 ARMv6-M 和 ARMv7-M 的处理器外，都有 30 个通用 32 位寄存器，前 16 个寄存器(r1-r15)可在用户级模式下访问，其他寄存器可在特权软件执行中使用（ARMv6-M 和 ARMv7-M 除外）。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;#&lt;/th&gt;
&lt;th&gt;Alias&lt;/th&gt;
&lt;th&gt;Purpose&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;R0&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;General purppose&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;R1&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;General purppose&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;R2&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;General purppose&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;R3&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;General purppose&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;R4&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;General purppose&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;R5&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;General purppose&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;R6&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;General purppose&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
<p>
		

	

	</div>
  <a type="button" href="/2021/08/11/Arm Instractions/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="DATA-Types"><a href="#DATA-Types" class="headerlink" title="DATA Types"></a>DATA Types</h2><p>与高级语言相似，ARM支持操作不同类型的数据类型。我们可以load（or stroe）的数据类型有signed and unsigned words、halfwords、or bytes. 这些数据类型的extensions分别是：halfwords是-h or -sh，bytes是-b or -sb，word没有extension. signed and unsinged 数据的区别：<br>    1.signed data type 能储存正数和负数，因此范围较小<br>    2.unsigned data type 可以保存大的正值（包括“零”），但不能保存负值，因此范围更广。</p>
<p>以下是一些load和store指令的操作指令的一些例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ldr = Load Word</span><br><span class="line">ldrh = Load <span class="keyword">unsigned</span> Half Word</span><br><span class="line">ldrsh = Load <span class="keyword">signed</span> Half Word</span><br><span class="line">ldrb = Load <span class="keyword">unsigned</span> Byte</span><br><span class="line">ldrsb = Load <span class="keyword">signed</span> Bytes</span><br><span class="line"></span><br><span class="line">str = Store Word</span><br><span class="line">strh = Store <span class="keyword">unsigned</span> Half Word</span><br><span class="line">strsh = Store <span class="keyword">signed</span> Half Word</span><br><span class="line">strb = Store <span class="keyword">unsigned</span> Byte</span><br><span class="line">strsb = Store <span class="keyword">signed</span> Byte</span><br></pre></td></tr></table></figure>

<p>查看内存中的字节有两种基本方式：Little-Endian (LE) 或 Big-Endian (BE)。 区别在于对象的每个字节存储在内存中的字节顺序。 在像 Intel x86 这样的小端机器上，最低有效字节存储在最低地址（最接近零的地址）。 在 big-endian 机器上，最高有效字节存储在最低地址。 ARM 体系结构在第 3 版之前是小端的，从那时起它是双端的，这意味着它具有允许可切换的端的设置。 例如，在 ARMv6 上，指令是固定的 little-endian，数据访问可以是 little-endian 或 big-endian，由程序状态寄存器 (CPSR) 的第 9 位（E 位）控制。</p>
<p>寄存器的数量是依赖于ARM的版本的，通过查询ARM Reference Manual，除了基于 ARMv6-M 和 ARMv7-M 的处理器外，都有 30 个通用 32 位寄存器，前 16 个寄存器(r1-r15)可在用户级模式下访问，其他寄存器可在特权软件执行中使用（ARMv6-M 和 ARMv7-M 除外）。</p>
<table>
<thead>
<tr>
<th>#</th>
<th>Alias</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td>R0</td>
<td>-</td>
<td>General purppose</td>
</tr>
<tr>
<td>R1</td>
<td>-</td>
<td>General purppose</td>
</tr>
<tr>
<td>R2</td>
<td>-</td>
<td>General purppose</td>
</tr>
<tr>
<td>R3</td>
<td>-</td>
<td>General purppose</td>
</tr>
<tr>
<td>R4</td>
<td>-</td>
<td>General purppose</td>
</tr>
<tr>
<td>R5</td>
<td>-</td>
<td>General purppose</td>
</tr>
<tr>
<td>R6</td>
<td>-</td>
<td>General purppose</td>
</tr>
<tr>
<td>R7</td>
<td>-</td>
<td>General purppose</td>
</tr>
<tr>
<td>R8</td>
<td>-</td>
<td>General purppose</td>
</tr>
<tr>
<td>R9</td>
<td>-</td>
<td>General purppose</td>
</tr>
<tr>
<td>R10</td>
<td>-</td>
<td>General purppose</td>
</tr>
<tr>
<td>R11</td>
<td>FP</td>
<td>Frame Pointer</td>
</tr>
<tr>
<td>R12</td>
<td>IP</td>
<td>Instra Procedural Call</td>
</tr>
<tr>
<td>R13</td>
<td>SP</td>
<td>Stack Pointer</td>
</tr>
<tr>
<td>R14</td>
<td>LR</td>
<td>Link Register</td>
</tr>
<tr>
<td>R15</td>
<td>PC</td>
<td>Program Counter</td>
</tr>
<tr>
<td>CPSR</td>
<td>-</td>
<td>Current Program Status Register</td>
</tr>
</tbody></table>
<p>下表只是快速了解 ARM 寄存器如何与 Intel 处理器中的寄存器相关联。</p>
<table>
<thead>
<tr>
<th>ARM</th>
<th>Description</th>
<th>x86</th>
</tr>
</thead>
<tbody><tr>
<td>R0</td>
<td>General Purpose</td>
<td>EAX</td>
</tr>
<tr>
<td>R1-R5</td>
<td>General Purpose</td>
<td>EBX, ECX, EDX, ESI, EDI</td>
</tr>
<tr>
<td>R6-R10</td>
<td>General Purpose</td>
<td>–</td>
</tr>
<tr>
<td>R11 (FP)</td>
<td>Frame Pointer</td>
<td>EBP</td>
</tr>
<tr>
<td>R12</td>
<td>Intra Procedural Call</td>
<td>–</td>
</tr>
<tr>
<td>R13 (SP)</td>
<td>Stack Pointer</td>
<td>ESP</td>
</tr>
<tr>
<td>R14 (LR)</td>
<td>Link Register</td>
<td>–</td>
</tr>
<tr>
<td>R15 (PC)</td>
<td>&lt;- Program Counter / Instruction Pointer -&gt;</td>
<td>EIP</td>
</tr>
<tr>
<td>CPSR</td>
<td>Current Program State Register/Flags</td>
<td>EFLAGS</td>
</tr>
</tbody></table>
<p>R0-R12：在普通的操作中可以被用作储存临时数据、指针等等。例如，R0 可在算术运算期间称为累加器或用于存储先前调用函数的结果。 R7 在处理系统调用时变得有用，因为它存储系统调用编号，而 R11 帮助我们跟踪用作帧指针的堆栈边界。 此外，ARM 上的函数调用约定指定函数的前四个参数存储在寄存器 r0-r3 中。</p>
<p>R13：SP(Stack Pointer). 这个栈指针指向栈顶，栈是用于特定于函数的存储的内存区域，在函数返回时被回收。 因此，栈指针用于在栈上分配空间，方法是从栈指针中减去我们想要分配的值（以字节为单位）。 换句话说，如果我们想分配一个 32 位的值，我们从栈指针中减去 4。</p>
<p>R14:LR(Link Register). 当一个函数调用被执行了，链接寄存器就会更新为下一条指令的内存地址。止痒允许程序在子函数完成后返回到父函数中接着执行。</p>
<p>R15:PC(Program Counter).程序计数器根据所执行指令的大小自动递增。 此大小在 ARM 状态下始终为 4 个字节，在 THUMB 模式下始终为 2 个字节。 当执行分支指令时，PC 持有目的地址。 在执行过程中，PC 在 ARM 状态下存储当前指令加 8（两条 ARM 指令）的地址，在 Thumb(v1) 状态下存储当前指令加 4（两条 Thumb 指令）的地址。 这与 x86 不同，在 x86 中 PC 总是指向要执行的下一条指令。</p>
<h3 id="下面在调试器下看一下PC寄存器的行为"><a href="#下面在调试器下看一下PC寄存器的行为" class="headerlink" title="下面在调试器下看一下PC寄存器的行为"></a>下面在调试器下看一下PC寄存器的行为</h3><p>源程序如下：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.section</span> <span class="meta">.text</span></span><br><span class="line"><span class="symbol">.global</span> _start</span><br><span class="line"></span><br><span class="line"><span class="symbol">_start:</span></span><br><span class="line"> <span class="keyword">mov</span> <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line"> <span class="keyword">mov</span> <span class="built_in">r1</span>, <span class="number">#2</span></span><br><span class="line"> <span class="keyword">add</span> <span class="built_in">r2</span>, <span class="built_in">r1</span>, <span class="built_in">r1</span></span><br><span class="line"> bkpt</span><br></pre></td></tr></table></figure>

<p>在GDB中我们设置断点_start然后运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; b _start</span><br><span class="line">Breakpoint 1 at 0x10054</span><br><span class="line">gef&gt; r</span><br></pre></td></tr></table></figure>

<p>断点的现场状态如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1, 0x00010054 in _start ()</span><br><span class="line">---------------------------------------------------------------[ registers ]----</span><br><span class="line">$r0   : 0x00000000</span><br><span class="line">$r1   : 0x00000000</span><br><span class="line">$r2   : 0x00000000</span><br><span class="line">$r3   : 0x00000000</span><br><span class="line">$r4   : 0x00000000</span><br><span class="line">$r5   : 0x00000000</span><br><span class="line">$r6   : 0x00000000</span><br><span class="line">$r7   : 0x00000000</span><br><span class="line">$r8   : 0x00000000</span><br><span class="line">$r9   : 0x00000000</span><br><span class="line">$r10  : 0x00000000</span><br><span class="line">$r11  : 0x00000000</span><br><span class="line">$r12  : 0x00000000</span><br><span class="line">$sp   : 0xbefff3b0 -&gt; 0x00000001</span><br><span class="line">$lr   : 0x00000000</span><br><span class="line">$pc   : 0x00010054 -&gt; &lt;_start+0&gt; mov r0,  pc</span><br><span class="line">$cpsr : [thumb fast interrupt overflow carry zero negative]</span><br><span class="line">-------------------------------------------------------------------[ stack ]----</span><br><span class="line">0xbefff3b0|+0x00: 0x00000001    &lt;-$sp</span><br><span class="line">0xbefff3b4|+0x04: 0xbefff51c -&gt; &quot;/home/pi/asm/test_pc&quot;</span><br><span class="line">0xbefff3b8|+0x08: 0x00000000</span><br><span class="line">0xbefff3bc|+0x0c: 0xbefff531 -&gt; 0x49464e49</span><br><span class="line">0xbefff3c0|+0x10: 0xbefff56b -&gt; &quot;XDG_SESSION_ID=c2&quot;</span><br><span class="line">0xbefff3c4|+0x14: 0xbefff57d -&gt; &quot;SHELL=/bin/bash&quot;</span><br><span class="line">0xbefff3c8|+0x18: 0xbefff58d -&gt; &quot;TERM=xterm&quot;</span><br><span class="line">0xbefff3cc|+0x1c: 0xbefff598 -&gt; 0x49464e49</span><br><span class="line">-------------------------------------------------------------[ code:armv5t ]----</span><br><span class="line">      0x1003c                  andeq  r0,  r1,  r0</span><br><span class="line">      0x10040                  andeq  r0,  r1,  r0</span><br><span class="line">      0x10044                  andeq  r0,  r0,  r4,  rrx</span><br><span class="line">      0x10048                  andeq  r0,  r0,  r4,  rrx</span><br><span class="line">      0x1004c                  andeq  r0,  r0,  r5</span><br><span class="line">      0x10050                  andeq  r0,  r1,  r0</span><br><span class="line">-&gt;   0x10054 &lt;_start+0&gt;       mov    r0,  pc</span><br><span class="line">      0x10058 &lt;_start+4&gt;       mov    r1,  #2</span><br><span class="line">      0x1005c &lt;_start+8&gt;       add    r2,  r1,  r1</span><br><span class="line">      0x10060 &lt;_start+12&gt;      bkpt   0x0000</span><br><span class="line">      0x10064                  andeq  r1,  r0,  r1,  asr #6</span><br><span class="line">      0x10068                  cmnvs  r5,  r0,  lsl #2</span><br><span class="line">-----------------------------------------------------------------[ threads ]----</span><br><span class="line">[#0] Id 1, Name: &quot;test_pc&quot;, stopped, reason: BREAKPOINT</span><br><span class="line">-------------------------------------------------------------------[ trace ]----</span><br><span class="line">[#0] 0x10054-&gt;Name: _start()</span><br><span class="line">-------------------------------------------------------------------------------- </span><br></pre></td></tr></table></figure>

<p>单步运行后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">0x00010058 in _start ()</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------------------------------------------------[ registers ]----</span><br><span class="line">$r0   : 0x0001005c -&gt; &lt;_start+8&gt; add r2,  r1,  r1</span><br><span class="line">$r1   : 0x00000000</span><br><span class="line">$r2   : 0x00000000</span><br><span class="line">$r3   : 0x00000000</span><br><span class="line">$r4   : 0x00000000</span><br><span class="line">$r5   : 0x00000000</span><br><span class="line">$r6   : 0x00000000</span><br><span class="line">$r7   : 0x00000000</span><br><span class="line">$r8   : 0x00000000</span><br><span class="line">$r9   : 0x00000000</span><br><span class="line">$r10  : 0x00000000</span><br><span class="line">$r11  : 0x00000000</span><br><span class="line">$r12  : 0x00000000</span><br><span class="line">$sp   : 0xbefff3b0 -&gt; 0x00000001</span><br><span class="line">$lr   : 0x00000000</span><br><span class="line">$pc   : 0x00010058 -&gt; &lt;_start+4&gt; mov r1,  #2</span><br><span class="line">$cpsr : [thumb fast interrupt overflow carry zero negative]</span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------------------------------------------[ stack ]----</span><br><span class="line">0xbefff3b0|+0x00: 0x00000001    &lt;-$sp</span><br><span class="line">0xbefff3b4|+0x04: 0xbefff51c -&gt; &quot;/home/pi/asm/test_pc&quot;</span><br><span class="line">0xbefff3b8|+0x08: 0x00000000</span><br><span class="line">0xbefff3bc|+0x0c: 0xbefff531 -&gt; 0x49464e49</span><br><span class="line">0xbefff3c0|+0x10: 0xbefff56b -&gt; &quot;XDG_SESSION_ID=c2&quot;</span><br><span class="line">0xbefff3c4|+0x14: 0xbefff57d -&gt; &quot;SHELL=/bin/bash&quot;</span><br><span class="line">0xbefff3c8|+0x18: 0xbefff58d -&gt; &quot;TERM=xterm&quot;</span><br><span class="line">0xbefff3cc|+0x1c: 0xbefff598 -&gt; 0x49464e49</span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------------------------------------[ code:armv5t ]----</span><br><span class="line">      0x10040                  andeq  r0,  r1,  r0</span><br><span class="line">      0x10044                  andeq  r0,  r0,  r4,  rrx</span><br><span class="line">      0x10048                  andeq  r0,  r0,  r4,  rrx</span><br><span class="line">      0x1004c                  andeq  r0,  r0,  r5</span><br><span class="line">      0x10050                  andeq  r0,  r1,  r0</span><br><span class="line">      0x10054 &lt;_start+0&gt;       mov    r0,  pc</span><br><span class="line">-&gt;   0x10058 &lt;_start+4&gt;       mov    r1,  #2</span><br><span class="line">      0x1005c &lt;_start+8&gt;       add    r2,  r1,  r1</span><br><span class="line">      0x10060 &lt;_start+12&gt;      bkpt   0x0000</span><br><span class="line">      0x10064                  andeq  r1,  r0,  r1,  asr #6</span><br><span class="line">      0x10068                  cmnvs  r5,  r0,  lsl #2</span><br><span class="line">      0x1006c                  tsteq  r0,  r2,  ror #18</span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------[ threads ]----</span><br><span class="line">[#0] Id 1, Name: &quot;test_pc&quot;, stopped, reason: SINGLE STEP</span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------------------------------------------[ trace ]----</span><br><span class="line">[#0] 0x10058-&gt;Name: _start()</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>奇妙的事情发生了，查看R0中的地址。 虽然我们希望 R0 包含先前读取的 PC 值 (0x10054)，但它保存的是我们先前读取的 PC (0x1005c) 前两条指令的值。 从这个例子可以看出，当我们直接读取PC时，它遵循PC指向下一条指令的定义； 但在调试时，PC 指向当前 PC 值（0x10054 + 8 = 0x1005C）之前的两条指令。 这是因为较旧的 ARM 处理器总是在当前执行的指令之前获取两条指令。 ARM 保留此定义的原因是为了确保与早期处理器的兼容性。</p>
<h3 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h3><p>寄存器 $CPSR 显示当前程序状态寄存器 (CPSR) 的值，在其下方您可以看到标志拇指、快速中断、溢出、进位、零和负数。 这些标志代表 CPSR 寄存器中的某些位，根据 CPSR 的值设置，激活时变为1。 N、Z、C 和 V 位与 x86 上 EFLAG 寄存器中的 SF、ZF、CF 和 OF 位相同。 这些位用于在程序集级别支持条件和循环中的条件执行</p>
<table>
<thead>
<tr>
<th>N</th>
<th>Z</th>
<th>C</th>
<th>V</th>
<th>Q</th>
<th>-</th>
<th>J</th>
<th>-</th>
<th>GE</th>
<th>-</th>
<th>E</th>
<th>A</th>
<th>I</th>
<th>F</th>
<th>T</th>
<th>M</th>
</tr>
</thead>
<tbody><tr>
<td>Negative</td>
<td>Zero</td>
<td>Carry</td>
<td>Overflow</td>
<td>underflow</td>
<td></td>
<td>Jazelle</td>
<td></td>
<td>Greater than or Equal for SIMD</td>
<td></td>
<td>Endianness</td>
<td>Abort disable</td>
<td>IRQ disable</td>
<td>FIQ disable</td>
<td>Thumb</td>
<td>Processor mode(Privilege mode)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>N(Negative)</td>
<td>如果指令结果是负数则置1.</td>
</tr>
<tr>
<td>Z(Zero)</td>
<td>如果指令结果产生零值则置1.</td>
</tr>
<tr>
<td>C(Carry)</td>
<td>如果指令的结果产生一个需要第 33 位才能完全表示的值，则置1.</td>
</tr>
<tr>
<td>V(Overflow)</td>
<td>如果该指令的结果产生不能在32位二进制补码表示的值.</td>
</tr>
<tr>
<td>E(Endian-bit)</td>
<td>ARM 可以以小端或大端方式运行。 对于小端模式，该位设置为 0，对于大端模式设置为 1.</td>
</tr>
<tr>
<td>T(Thumb-bit)</td>
<td>如果是Thumb模式置1，如果是ARM模式置0.</td>
</tr>
<tr>
<td>M(Mode-bits)</td>
<td>这些位指定当前特权模式（USR、SVC 等）.</td>
</tr>
<tr>
<td>J(Jazelle)</td>
<td>允许某些 ARM 处理器在硬件中执行 Java 字节码的第三种执行状态.</td>
</tr>
</tbody></table>
<p>APSR包含下列ALU的状态标志：</p>
<p>N-当操作结果为负数时设置；</p>
<p>Z-当操作结果为0时设置；</p>
<p>C-当操作导致进位时设置；</p>
<p>V-当操作造成溢出时设置。</p>
<p>在下列情况下，进位发生:</p>
<ol>
<li>如果加法的结果大于或等于 2^32，</li>
<li>如果减法的结果是正数或零，</li>
<li>作为move or logical指令中的内联桶形移位器操作的结果。</li>
</ol>
<p>如果加法、减法或比较的结果大于或等于 2^31，或小于 –2^31，溢出发生。</p>
<h2 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h2><p>ARM 处理器有两个主要的状态可以运行（这里不计算 Jazelle），ARM 和 Thumb。 这些状态与特权级别无关。 例如，在 SVC 模式下运行的代码可以是 ARM 或 Thumb。 这两种状态的主要区别在于指令集，其中ARM状态的指令总是32位的，Thumb状态的指令是16位的（但也可以是32位的）。 了解何时以及如何使用 Thumb 对于我们的 ARM 漏洞利用开发目的尤其重要。 在编写 ARM shellcode 时，我们需要去掉 NULL 字节，使用 16 位 Thumb 指令而不是 32 位 ARM 指令减少了拥有它们的机会。</p>
<p>这里有不同的Thumb版本：</p>
<ol>
<li>Thumb-1 (16-bit instructions): 在 ARMv6 and 更早的架构中使用.</li>
<li>Thumb-2 (16-bit and 32-bit instructions): 扩展了 Thumb-1 通过加了更多的指令并且允许它们可以是16bits和32bits(ARMv6T2, ARMv7).</li>
<li>ThumbEE: 包含了一些改变和添加使其能够动态的添加和生成代码（在执行之前或执行期间在设备上编译的代码）。</li>
</ol>
<p>ARM和Thumb之间的差别：</p>
<ol>
<li>条件执行，ARM状态下的所有的指令都支持条件执行，某些 ARM 处理器版本允许使用 IT 指令在 Thumb 中进行条件执行。 条件执行导致更高的代码密度，因为它减少了要执行的指令数量并减少分支预测的指令数量。</li>
<li>32位的ARM和Thumb指令：32位的Thumb指令有.w后缀。</li>
<li>桶形移位器是另一个独特的 ARM 模式功能。 它可用于将多条指令压缩为一条指令。例如，不使用两条指令进行乘法（将寄存器乘以 2 并使用 MOV 将结果存储到另一个寄存器中），您可以通过使用左移 1 -&gt; <code>Mov R1, R0, LSL #1</code> 将乘法包含在 MOV 指令中; <code>R1 = R0 * 2</code>.</li>
</ol>
<p>要切换处理器执行的状态，必须满足以下两个条件之一：</p>
<ol>
<li>我们可以使用分支指令BX (branch and exchange) or BLX (branch, link, and exchange) ，将目标寄存器的最低有效位设置为 1。这可以通过向偏移量加 1 来实现，例如 0x5530 + 1。您可能认为这会导致对齐问题，因为指令是 2 字节或 4 字节对齐的。 这不是问题，因为处理器将忽略最低有效位。</li>
<li>如果当前程序状态寄存器中的 T 位被设置，我们就知道我们处于 Thumb 模式。</li>
</ol>
<h3 id="Briefly-introduce-into-ARM-Instructions"><a href="#Briefly-introduce-into-ARM-Instructions" class="headerlink" title="Briefly introduce into ARM Instructions"></a>Briefly introduce into ARM Instructions</h3><p>汇编语言由作为主要构建块的指令组成。 ARM 指令通常后跟一两个操作数，一般使用以下模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MNEMONIC&#123;S&#125;&#123;condition&#125; &#123;Rd&#125;, Operand1, Operand2</span><br></pre></td></tr></table></figure>

<p>由于 ARM 指令集的灵活性，并非所有指令都使用模板中提供的所有字段。模板中字段的用途描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MNEMONIC     - Short name (mnemonic) of the instruction</span><br><span class="line">&#123;S&#125;          - An optional suffix. If S is specified, the condition flags are updated on the result of the operation</span><br><span class="line">&#123;condition&#125;  - Condition that is needed to be met in order for the instruction to be executed</span><br><span class="line">&#123;Rd&#125;         - Register (destination) for storing the result of the instruction</span><br><span class="line">Operand1     - First operand. Either a register or an immediate value </span><br><span class="line">Operand2     - Second (flexible) operand. Can be an immediate value (number) or a register with an optional shift</span><br></pre></td></tr></table></figure>

<p>MNEMONIC、S、Rd 和 Operand1 字段是比较直观的，但条件和 Operand2 字段需要更多说明。 条件字段与 CPSR 寄存器的值密切相关，或者准确地说，是寄存器中特定位的值。 Operand2 被称为灵活操作数，因为我们可以以各种形式使用它——作为立即数（具有有限的值集）、寄存器或带有移位的寄存器。 例如，我们可以将这些表达式用作 Operand2：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#123                    - Immediate value (with limited set of values). </span></span><br><span class="line"><span class="symbol">Rx</span>                      - Register x (like <span class="built_in">R1</span>, <span class="built_in">R2</span>, <span class="built_in">R3</span> ...)</span><br><span class="line"><span class="symbol">Rx</span>, <span class="keyword">ASR</span> n               - Register x with arithmetic shift right by n bits (<span class="number">1</span> = n = <span class="number">32</span>)</span><br><span class="line"><span class="symbol">Rx</span>, <span class="keyword">LSL</span> n               - Register x with logical shift left by n bits (<span class="number">0</span> = n = <span class="number">31</span>)</span><br><span class="line"><span class="symbol">Rx</span>, <span class="keyword">LSR</span> n               - Register x with logical shift right by n bits (<span class="number">1</span> = n = <span class="number">32</span>)</span><br><span class="line"><span class="symbol">Rx</span>, <span class="keyword">ROR</span> n               - Register x with rotate right by n bits (<span class="number">1</span> = n = <span class="number">31</span>)</span><br><span class="line"><span class="symbol">Rx</span>, <span class="keyword">RRX</span>                 - Register x with rotate right by one bit, with extend</span><br></pre></td></tr></table></figure>

<p>不同种类的指令的例子如下所示：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span>   <span class="built_in">R0</span>, <span class="built_in">R1</span>, <span class="built_in">R2</span>         - <span class="keyword">Adds</span> contents of <span class="built_in">R1</span> (Operand1) <span class="keyword">and</span> <span class="built_in">R2</span> (Operand2 in a form of register) <span class="keyword">and</span> stores the result into <span class="built_in">R0</span> (Rd)</span><br><span class="line"><span class="keyword">ADD</span>   <span class="built_in">R0</span>, <span class="built_in">R1</span>, <span class="number">#2</span>         - <span class="keyword">Adds</span> contents of <span class="built_in">R1</span> (Operand1) <span class="keyword">and</span> the value <span class="number">2</span> (Operand2 in a form of an immediate value) <span class="keyword">and</span> stores the result into <span class="built_in">R0</span> (Rd)</span><br><span class="line"><span class="keyword">MOVLE</span> <span class="built_in">R0</span>, <span class="number">#5</span>             - Moves number <span class="number">5</span> (Operand2, because the compiler treats <span class="keyword">it</span> as <span class="keyword">MOVLE</span> <span class="built_in">R0</span>, <span class="built_in">R0</span>, <span class="number">#5</span>) to <span class="built_in">R0</span> (Rd) ONLY <span class="meta">if</span> the condition LE (Less Than or Equal) is satisfied</span><br><span class="line"><span class="keyword">MOV</span>   <span class="built_in">R0</span>, <span class="built_in">R1</span>, <span class="keyword">LSL</span> <span class="number">#1</span>     - Moves the contents of <span class="built_in">R1</span> (Operand2 in a form of register with logical shift left) shifted left by one bit to <span class="built_in">R0</span> (Rd). So <span class="meta">if</span> <span class="built_in">R1</span> had value <span class="number">2</span>, <span class="keyword">it</span> gets shifted left by one bit <span class="keyword">and</span> becomes <span class="number">4</span>. <span class="number">4</span> is then moved to <span class="built_in">R0</span>.</span><br></pre></td></tr></table></figure>

<p>总结下：</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Description</th>
<th>Instruction</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>MOV</td>
<td>Move data</td>
<td>EOR</td>
<td>Bitwise XOR</td>
</tr>
<tr>
<td>MVN</td>
<td>Move and negate</td>
<td>LDR</td>
<td>Load</td>
</tr>
<tr>
<td>ADD</td>
<td>Addition</td>
<td>STR</td>
<td>Store</td>
</tr>
<tr>
<td>SUB</td>
<td>Subtraction</td>
<td>LDM</td>
<td>Load Multiple</td>
</tr>
<tr>
<td>MUL</td>
<td>Multiplication</td>
<td>STM</td>
<td>Store Multiple</td>
</tr>
<tr>
<td>LSL</td>
<td>Logical Shift Left</td>
<td>PUSH</td>
<td>Push on Stack</td>
</tr>
<tr>
<td>LSR</td>
<td>Logical Shift Right</td>
<td>POP</td>
<td>Pop off Stack</td>
</tr>
<tr>
<td>ASR</td>
<td>Arithmetic Shift Right</td>
<td>B</td>
<td>Branch</td>
</tr>
<tr>
<td>ROR</td>
<td>Rotate Right</td>
<td>BL</td>
<td>Branch with Link</td>
</tr>
<tr>
<td>CMP</td>
<td>Compare</td>
<td>BX</td>
<td>Branch and eXchange</td>
</tr>
<tr>
<td>AND</td>
<td>Bitwise AND</td>
<td>BLX</td>
<td>Branch with Link and eXchange</td>
</tr>
<tr>
<td>ORR</td>
<td>Bitwise OR</td>
<td>SWI/SVC</td>
<td>System Call</td>
</tr>
</tbody></table>
<h2 id="load-and-store-Instruction"><a href="#load-and-store-Instruction" class="headerlink" title="load and store Instruction"></a>load and store Instruction</h2><p>ARM使用load-store模式进行内存的访问，这意味着只能使用load/store(LDR and LDR)指令能访问内存。而x86允许直接在内存上操作数据，在arm上数据在操作前必须被move到寄存器中。这意味着在 ARM 上的特定内存地址处递增 32 位值将需要三种类型的指令(load, increment, and store) 来首先将特定地址处的值加载到寄存器中，在寄存器中递增它，然后将它从寄存器存储回内存。为了解释 ARM 上加载和存储操作的基本原理，我们从一个基本示例开始，然后继续介绍三种基本偏移量形式，每种偏移量形式具有三种不同的地址模式。 对于每个示例，我们将使用具有不同 LDR/STR 偏移形式的同一段汇编代码，以保持简单。</p>
<p>立即数作为偏移：<br>地址模式: 偏移<br>地址模式: 预先索引<br>地址模式: 后索引<br>寄存器作为偏移:<br>地址模式: 偏移<br>地址模式: 预先索引<br>地址模式: 后索引<br>Scaled register作为偏移<br>地址模式: 偏移<br>地址模式: 预先索引<br>地址模式: 后索引</p>
<p>通常，LDR用于将内存中的某些内容加载到寄存器中，STR用于将存储器中的某些内容存储到内存地址。</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LDR</span> <span class="built_in">R2</span>, [<span class="built_in">R0</span>]   <span class="comment">@ [R0] - origin address is the value found in R0.</span></span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R2</span>, [<span class="built_in">R1</span>]   <span class="comment">@ [R1] - destination address is the value found in R1.</span></span><br></pre></td></tr></table></figure>

<p>LDR操作：将R0中找到的地址上的值加载到目标寄存器R2。</p>
<p>STR操作：将R2中找到的值存储到R1中找到的内存地址。</p>
<h3 id="example-1"><a href="#example-1" class="headerlink" title="example 1"></a>example 1</h3><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.data</span>          <span class="comment">/* the .data section is dynamically created and its addresses cannot be easily predicted */</span></span><br><span class="line"><span class="symbol">var1:</span> <span class="meta">.word</span> <span class="number">3</span>  <span class="comment">/* variable 1 in memory */</span></span><br><span class="line"><span class="symbol">var2:</span> <span class="meta">.word</span> <span class="number">4</span>  <span class="comment">/* variable 2 in memory */</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.text</span>          <span class="comment">/* start of the text (code) section */</span> </span><br><span class="line"><span class="symbol">.global</span> _start</span><br><span class="line"></span><br><span class="line"><span class="symbol">_start:</span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r0</span>, adr_var1  <span class="comment">@ load the memory address of var1 via label adr_var1 into R0 </span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r1</span>, adr_var2  <span class="comment">@ load the memory address of var2 via label adr_var2 into R1 </span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r2</span>, [<span class="built_in">r0</span>]      <span class="comment">@ load the value (0x03) at memory address found in R0 to register R2  </span></span><br><span class="line">    <span class="keyword">str</span> <span class="built_in">r2</span>, [<span class="built_in">r1</span>]      <span class="comment">@ store the value found in R2 (0x03) to the memory address found in R1 </span></span><br><span class="line">    <span class="keyword">bkpt</span>             </span><br><span class="line"></span><br><span class="line"><span class="symbol">adr_var1:</span> <span class="meta">.word</span> var1  <span class="comment">/* address to var1 stored here */</span></span><br><span class="line"><span class="symbol">adr_var2:</span> <span class="meta">.word</span> var2  <span class="comment">/* address to var2 stored here */</span></span><br></pre></td></tr></table></figure>

<p>在底部，我们有我们的 Literal Pool（同一代码段中的一个内存区域，用于存储其他人可以以与位置无关的方式引用的常量、字符串或偏移量），其中存储了 var1 和 var2 的内存地址（在顶部的数据部分）使用标签 adr_var1 和 adr_var2。第一个 LDR 将 var1 的地址加载到寄存器 R0 中。第二个 LDR 对 var2 执行相同的操作并将其加载到 R1。然后我们将存储在 R0 中找到的内存地址的值加载到 R2，并将 R2 中找到的值存储到 R1 中找到的内存地址。</p>
<p>当我们将某些内容加载到寄存器中时，方括号 ([ ]) 表示：在这些方括号之间的寄存器中找到的值是我们要从中加载某些内容的内存地址。</p>
<p>当我们将内容存储到内存位置时，方括号 ([]) 表示：在这些方括号之间的寄存器中找到的值是我们想要存储内容的内存地址。</p>
<p>调试器中的代码片段：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-&gt;   <span class="number">0x10074</span> &lt;_start+<span class="number">0</span>&gt;       <span class="keyword">ldr</span>    <span class="built_in">r0</span>,  [<span class="built_in">pc</span>,  <span class="number">#12</span>]    <span class="comment">; 0x10088 &lt;adr_var1&gt;</span></span><br><span class="line">      <span class="number">0x10078</span> &lt;_start+<span class="number">4</span>&gt;       <span class="keyword">ldr</span>    <span class="built_in">r1</span>,  [<span class="built_in">pc</span>,  <span class="number">#12</span>]     <span class="number">0x1008c</span> &lt;adr_var2&gt;</span><br><span class="line">      <span class="number">0x1007c</span> &lt;_start+<span class="number">8</span>&gt;       <span class="keyword">ldr</span>    <span class="built_in">r2</span>,  [<span class="built_in">r0</span>]</span><br><span class="line">      <span class="number">0x10080</span> &lt;_start+<span class="number">12</span>&gt;      <span class="keyword">str</span>    <span class="built_in">r2</span>,  [<span class="built_in">r1</span>]</span><br><span class="line">      <span class="number">0x10084</span> &lt;_start+<span class="number">16</span>&gt;      <span class="keyword">bkpt</span>   <span class="number">0x0000</span></span><br><span class="line">      <span class="number">0x10088</span> &lt;adr_var1+<span class="number">0</span>&gt;     <span class="keyword">muleq</span>  <span class="built_in">r2</span>,  <span class="built_in">r0</span>,  <span class="built_in">r0</span></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------[ threads ]----</span><br><span class="line">[<span class="number">#0</span>] Id <span class="number">1</span>, Name: <span class="string">&quot;test_pc&quot;</span>, stopped, reason: BREAKPOINT</span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------------------------------------------[ trace ]----</span><br><span class="line">[<span class="number">#0</span>] <span class="number">0x10074</span>-&gt;Name: _start()</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="symbol">gef</span>&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在前两个 LDR 操作中指定的标签更改为 [pc, #12]。这称为 PC 相对寻址。因为我们使用了标签，所以编译器计算了我们在文字池 (PC+12) 中指定的值的位置。您可以使用这种精确方法自己计算位置，也可以像我们之前所做的那样使用标签。唯一的区别是，您需要计算您的值在 Literal Pool 中的确切位置，而不是使用标签。在这种情况下，它距离有效 PC 位置 3 跳（4+4+4=12）。</p>
<h4 id="立即数作为偏移"><a href="#立即数作为偏移" class="headerlink" title="立即数作为偏移"></a>立即数作为偏移</h4><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">STR</span>    Ra, [Rb, imm]</span><br><span class="line"><span class="keyword">LDR</span>    Ra, [Rc, imm]</span><br></pre></td></tr></table></figure>

<p>这里我们使用立即数（整数）作为偏移量。 该值与基址寄存器（下例中的 R1）相加或相减，以在编译时已知的偏移量处访问数据。</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.data</span></span><br><span class="line"><span class="symbol">var1:</span> <span class="meta">.word</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">var2:</span> <span class="meta">.word</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.text</span></span><br><span class="line"><span class="symbol">.global</span> _start</span><br><span class="line"></span><br><span class="line"><span class="symbol">_start:</span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r0</span>, adr_var1  <span class="comment">@ load the memory address of var1 via label adr_var1 into R0</span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r1</span>, adr_var2  <span class="comment">@ load the memory address of var2 via label adr_var2 into R1</span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r2</span>, [<span class="built_in">r0</span>]      <span class="comment">@ load the value (0x03) at memory address found in R0 to register R2 </span></span><br><span class="line">    <span class="keyword">str</span> <span class="built_in">r2</span>, [<span class="built_in">r1</span>, <span class="number">#2</span>]  <span class="comment">@ address mode: offset. Store the value found in R2 (0x03) to the memory address found in R1 plus 2. Base register (R1) unmodified. </span></span><br><span class="line">    <span class="keyword">str</span> <span class="built_in">r2</span>, [<span class="built_in">r1</span>, <span class="number">#4</span>]! <span class="comment">@ address mode: pre-indexed. Store the value found in R2 (0x03) to the memory address found in R1 plus 4. Base register (R1) modified: R1 = R1+4 </span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r3</span>, [<span class="built_in">r1</span>], <span class="number">#4</span>  <span class="comment">@ address mode: post-indexed. Load the value at memory address found in R1 to register R3. Base register (R1) modified: R1 = R1+4 </span></span><br><span class="line">    <span class="keyword">bkpt</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">adr_var1:</span> <span class="meta">.word</span> var1</span><br><span class="line"><span class="symbol">adr_var2:</span> <span class="meta">.word</span> var2</span><br></pre></td></tr></table></figure>

<p>将在偏移地址模式下执行 STR 操作的下一条指令。 它会将 R2 (0x00000003) 中的值存储到 R1 (0x0001009c) 中指定的内存地址 + 偏移量 (#2) = 0x1009e。</p>
<h4 id="寄存器作为偏移"><a href="#寄存器作为偏移" class="headerlink" title="寄存器作为偏移"></a>寄存器作为偏移</h4><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">STR</span>    Ra, [Rb, Rc]</span><br><span class="line"><span class="keyword">LDR</span>    Ra, [Rb, Rc]</span><br></pre></td></tr></table></figure>

<p>这种偏移形式使用寄存器作为偏移。 这种偏移形式的一个示例用法是当您的代码想要访问在运行时计算索引的数组时。</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.data</span></span><br><span class="line"><span class="symbol">var1:</span> <span class="meta">.word</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">var2:</span> <span class="meta">.word</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.text</span></span><br><span class="line"><span class="symbol">.global</span> _start</span><br><span class="line"></span><br><span class="line"><span class="symbol">_start:</span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r0</span>, adr_var1  <span class="comment">@ load the memory address of var1 via label adr_var1 to R0 </span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r1</span>, adr_var2  <span class="comment">@ load the memory address of var2 via label adr_var2 to R1 </span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r2</span>, [<span class="built_in">r0</span>]      <span class="comment">@ load the value (0x03) at memory address found in R0 to R2</span></span><br><span class="line">    <span class="keyword">str</span> <span class="built_in">r2</span>, [<span class="built_in">r1</span>, <span class="built_in">r2</span>]  <span class="comment">@ address mode: offset. Store the value found in R2 (0x03) to the memory address found in R1 with the offset R2 (0x03). Base register unmodified.   </span></span><br><span class="line">    <span class="keyword">str</span> <span class="built_in">r2</span>, [<span class="built_in">r1</span>, <span class="built_in">r2</span>]! <span class="comment">@ address mode: pre-indexed. Store value found in R2 (0x03) to the memory address found in R1 with the offset R2 (0x03). Base register modified: R1 = R1+R2. </span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r3</span>, [<span class="built_in">r1</span>], <span class="built_in">r2</span>  <span class="comment">@ address mode: post-indexed. Load value at memory address found in R1 to register R3. Then modify base register: R1 = R1+R2.</span></span><br><span class="line">    <span class="keyword">bx</span> <span class="built_in">lr</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">adr_var1:</span> <span class="meta">.word</span> var1</span><br><span class="line"><span class="symbol">adr_var2:</span> <span class="meta">.word</span> var2</span><br></pre></td></tr></table></figure>

<p>在偏移地址模式下执行第一个STR操作后，R2的值（0x00000003）将存储在内存地址0x0001009c + 0x00000003 = 0x0001009F。</p>
<h4 id="Scaled寄存器作偏移"><a href="#Scaled寄存器作偏移" class="headerlink" title="Scaled寄存器作偏移"></a>Scaled寄存器作偏移</h4><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LDR</span>    Ra, [Rb, Rc, &lt;shifter&gt;]</span><br><span class="line"><span class="keyword">STR</span>    Ra, [Rb, Rc, &lt;shifter&gt;]</span><br></pre></td></tr></table></figure>

<p>第三种偏移形式有一个缩放寄存器作为偏移。 在这种情况下，Rb 是基址寄存器，Rc 是立即偏移量（或包含立即值的寄存器）左/右移位 (&lt;shifter&gt;) 以缩放立即数。 这意味着桶形移位器用于缩放偏移。 这种偏移形式的一个示例用法是循环遍历数组。</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.data</span></span><br><span class="line"><span class="symbol">var1:</span> <span class="meta">.word</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">var2:</span> <span class="meta">.word</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.text</span></span><br><span class="line"><span class="symbol">.global</span> _start</span><br><span class="line"></span><br><span class="line"><span class="symbol">_start:</span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r0</span>, adr_var1         <span class="comment">@ load the memory address of var1 via label adr_var1 to R0</span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r1</span>, adr_var2         <span class="comment">@ load the memory address of var2 via label adr_var2 to R1</span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r2</span>, [<span class="built_in">r0</span>]             <span class="comment">@ load the value (0x03) at memory address found in R0 to R2</span></span><br><span class="line">    <span class="keyword">str</span> <span class="built_in">r2</span>, [<span class="built_in">r1</span>, <span class="built_in">r2</span>, LSL<span class="number">#2</span>]  <span class="comment">@ address mode: offset. Store the value found in R2 (0x03) to the memory address found in R1 with the offset R2 left-shifted by 2. Base register (R1) unmodified.</span></span><br><span class="line">    <span class="keyword">str</span> <span class="built_in">r2</span>, [<span class="built_in">r1</span>, <span class="built_in">r2</span>, LSL<span class="number">#2</span>]! <span class="comment">@ address mode: pre-indexed. Store the value found in R2 (0x03) to the memory address found in R1 with the offset R2 left-shifted by 2. Base register modified: R1 = R1 + R2&lt;&lt;2</span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r3</span>, [<span class="built_in">r1</span>], <span class="built_in">r2</span>, LSL<span class="number">#2</span>  <span class="comment">@ address mode: post-indexed. Load value at memory address found in R1 to the register R3. Then modifiy base register: R1 = R1 + R2&lt;&lt;2</span></span><br><span class="line">    <span class="keyword">bkpt</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">adr_var1:</span> <span class="meta">.word</span> var1</span><br><span class="line"><span class="symbol">adr_var2:</span> <span class="meta">.word</span> var2</span><br></pre></td></tr></table></figure>

<p>第一个 STR 操作使用偏移地址模式，并将在 R2 中找到的值存储在从 [r1, r2, LSL#2] 计算出的内存位置，这意味着它以 R1 中的值为基数（在这种情况下，R1 包含 var2 的内存地址)，然后取 R2 (0x3) 中的值，并将其左移 2。下图是尝试可视化如何使用 [r1, r2, LSL#2] 计算内存位置 .</p>
<h3 id="在arm上使用立即数"><a href="#在arm上使用立即数" class="headerlink" title="在arm上使用立即数"></a>在arm上使用立即数</h3><p>在 ARM 上的寄存器中加载立即值并不像在 x86 上那样简单。您可以使用哪些直接值是有限制的。可以使用一些技巧来绕过这些限制（提示：LDR）。</p>
<p>我们知道每条 ARM 指令都是 32bit 长的，所有指令都是有条件的。我们可以使用16个条件码，一个条件码占指令的4位。然后我们需要 2 位作为目标寄存器。 2 位用于第一个操作数寄存器，1 位用于设置状态标志，以及用于其他事项（如实际操作码）的各种位。这里的重点是，在为指令类型、寄存器和其他字段分配位后，立即数只剩下 12 位，这将只允许 4096 个不同的值。</p>
<p>这意味着 ARM 指令只能直接在 MOV 中使用有限范围的立即数。如果一个数字不能直接使用，就必须把它分成几部分，由多个较小的数字拼凑起来。</p>
<p>但还有更多。不是将 12 位用于单个整数，而是将这 12 位拆分为一个 8 位数字 (n)，能够加载 0-255 范围内的任何 8 位值，以及一个 4 位旋转字段 (r) 作为一个在 0 到 30 之间以 2 为步长向右循环。这意味着完整的立即数 v 由以下公式给出：v = n ror 2*r。换句话说，唯一有效的立即数是循环字节（可以减少到循环一个偶数的字节的值）。</p>
<p>以下是一些有效和无效的立即数的例子：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Valid</span> values:</span><br><span class="line"><span class="comment">#256        // 1 ror 24 --&gt; 256</span></span><br><span class="line"><span class="comment">#384        // 6 ror 26 --&gt; 384</span></span><br><span class="line"><span class="comment">#484        // 121 ror 30 --&gt; 484</span></span><br><span class="line"><span class="comment">#16384      // 1 ror 18 --&gt; 16384</span></span><br><span class="line"><span class="comment">#2030043136 // 121 ror 8 --&gt; 2030043136</span></span><br><span class="line"><span class="comment">#0x06000000 // 6 ror 8 --&gt; 100663296 (0x06000000 in hex)</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">Invalid</span> values:</span><br><span class="line"><span class="comment">#370        // 185 ror 31 --&gt; 31 is not in range (0 – 30)</span></span><br><span class="line"><span class="comment">#511        // 1 1111 1111 --&gt; bit-pattern can’t fit into one byte</span></span><br><span class="line"><span class="comment">#0x06010000 // 1 1000 0001.. --&gt; bit-pattern can’t fit into one byte</span></span><br></pre></td></tr></table></figure>

<p>这导致无法一次性加载完整的 32 位地址。 我们可以使用以下两个选项之一绕过此限制：</p>
<ol>
<li>用较小的部分构造较大的值：不使用<code>Mov r0 ,#511</code>,分割511到两部分:<code>MOV r0, #256, and ADD r0, #255</code></li>
<li>使用加载结构<code>ldr r1,=value</code>，如果不可能，汇编器会很乐意将其转换为 MOV 或与 PC 相关的加载。比如：<code>LDR r1, =511</code></li>
</ol>
<p>如果你试图加载一个无效的立即数，汇编器会产生一个错误，”Error: invalid constant.”,<br>如果您需要弄清楚某个数字是否可以用作有效的立即数，则无需自己计算。 您可以使用我的名为 <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/azeria-labs/rotator/master/rotator.py">rotator.py</a> 的小 Python 脚本，它将您的号码作为输入并告诉您它是否可以用作有效的立即数。</p>
<p>rotator.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function   <span class="comment"># PEP 3105</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rotate right: 0b1001 --&gt; 0b1100</span></span><br><span class="line">ror = <span class="keyword">lambda</span> val, r_bits, max_bits: \</span><br><span class="line">    ((val &amp; (<span class="number">2</span>**max_bits-<span class="number">1</span>)) &gt;&gt; r_bits%max_bits) | \</span><br><span class="line">    (val &lt;&lt; (max_bits-(r_bits%max_bits)) &amp; (<span class="number">2</span>**max_bits-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">max_bits = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = <span class="built_in">int</span>(raw_input(<span class="string">&quot;Enter the value you want to check: &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">256</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="number">31</span>, <span class="number">2</span>):</span><br><span class="line"></span><br><span class="line">        rotated = ror(n, i, max_bits)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rotated == <span class="built_in">input</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The number %i can be used as a valid immediate number.&quot;</span> % <span class="built_in">input</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%i ror %x --&gt; %s&quot;</span> % (n, <span class="built_in">int</span>(<span class="built_in">str</span>(i), <span class="number">16</span>), rotated))</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line">            sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sorry, %i cannot be used as an immediate number and has to be split.&quot;</span> % <span class="built_in">input</span>)</span><br></pre></td></tr></table></figure>

<h2 id="load-store-多个值"><a href="#load-store-多个值" class="headerlink" title="load/store 多个值"></a>load/store 多个值</h2><p>有时一次加载（或存储）多个值更有效。为此，我们使用LDM（负载倍数）和STM（存储倍数）。这些指令的变体基本上只因访问初始地址的方式而异。这是我们本节将使用的代码。我们将一步一步地完成每项指令。</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.data</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">array_buff:</span></span><br><span class="line"> <span class="meta">.word</span> <span class="number">0x00000000</span>             <span class="comment">/* array_buff[0] */</span></span><br><span class="line"> <span class="meta">.word</span> <span class="number">0x00000000</span>             <span class="comment">/* array_buff[1] */</span></span><br><span class="line"> <span class="meta">.word</span> <span class="number">0x00000000</span>             <span class="comment">/* array_buff[2]. This element has a relative address of array_buff+8 */</span></span><br><span class="line"> <span class="meta">.word</span> <span class="number">0x00000000</span>             <span class="comment">/* array_buff[3] */</span></span><br><span class="line"> <span class="meta">.word</span> <span class="number">0x00000000</span>             <span class="comment">/* array_buff[4] */</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.text</span></span><br><span class="line"><span class="symbol">.global</span> _start</span><br><span class="line"></span><br><span class="line"><span class="symbol">_start:</span></span><br><span class="line"> <span class="keyword">adr</span> <span class="built_in">r0</span>, words+<span class="number">12</span>             <span class="comment">/* address of words[3] -&gt; r0 */</span></span><br><span class="line"> <span class="keyword">ldr</span> <span class="built_in">r1</span>, array_buff_bridge    <span class="comment">/* address of array_buff[0] -&gt; r1 */</span></span><br><span class="line"> <span class="keyword">ldr</span> <span class="built_in">r2</span>, array_buff_bridge+<span class="number">4</span>  <span class="comment">/* address of array_buff[2] -&gt; r2 */</span></span><br><span class="line"> <span class="keyword">ldm</span> <span class="built_in">r0</span>, &#123;<span class="built_in">r4</span>,<span class="built_in">r5</span>&#125;              <span class="comment">/* words[3] -&gt; r4 = 0x03; words[4] -&gt; r5 = 0x04 */</span></span><br><span class="line"> <span class="keyword">stm</span> <span class="built_in">r1</span>, &#123;<span class="built_in">r4</span>,<span class="built_in">r5</span>&#125;              <span class="comment">/* r4 -&gt; array_buff[0] = 0x03; r5 -&gt; array_buff[1] = 0x04 */</span></span><br><span class="line"> <span class="keyword">ldmia</span> <span class="built_in">r0</span>, &#123;<span class="built_in">r4</span>-<span class="built_in">r6</span>&#125;            <span class="comment">/* words[3] -&gt; r4 = 0x03, words[4] -&gt; r5 = 0x04; words[5] -&gt; r6 = 0x05; */</span></span><br><span class="line"> <span class="keyword">stmia</span> <span class="built_in">r1</span>, &#123;<span class="built_in">r4</span>-<span class="built_in">r6</span>&#125;            <span class="comment">/* r4 -&gt; array_buff[0] = 0x03; r5 -&gt; array_buff[1] = 0x04; r6 -&gt; array_buff[2] = 0x05 */</span></span><br><span class="line"> <span class="keyword">ldmib</span> <span class="built_in">r0</span>, &#123;<span class="built_in">r4</span>-<span class="built_in">r6</span>&#125;            <span class="comment">/* words[4] -&gt; r4 = 0x04; words[5] -&gt; r5 = 0x05; words[6] -&gt; r6 = 0x06 */</span></span><br><span class="line"> <span class="keyword">stmib</span> <span class="built_in">r1</span>, &#123;<span class="built_in">r4</span>-<span class="built_in">r6</span>&#125;            <span class="comment">/* r4 -&gt; array_buff[1] = 0x04; r5 -&gt; array_buff[2] = 0x05; r6 -&gt; array_buff[3] = 0x06 */</span></span><br><span class="line"> <span class="keyword">ldmda</span> <span class="built_in">r0</span>, &#123;<span class="built_in">r4</span>-<span class="built_in">r6</span>&#125;            <span class="comment">/* words[3] -&gt; r6 = 0x03; words[2] -&gt; r5 = 0x02; words[1] -&gt; r4 = 0x01 */</span></span><br><span class="line"> <span class="keyword">ldmdb</span> <span class="built_in">r0</span>, &#123;<span class="built_in">r4</span>-<span class="built_in">r6</span>&#125;            <span class="comment">/* words[2] -&gt; r6 = 0x02; words[1] -&gt; r5 = 0x01; words[0] -&gt; r4 = 0x00 */</span></span><br><span class="line"> <span class="keyword">stmda</span> <span class="built_in">r2</span>, &#123;<span class="built_in">r4</span>-<span class="built_in">r6</span>&#125;            <span class="comment">/* r6 -&gt; array_buff[2] = 0x02; r5 -&gt; array_buff[1] = 0x01; r4 -&gt; array_buff[0] = 0x00 */</span></span><br><span class="line"> <span class="keyword">stmdb</span> <span class="built_in">r2</span>, &#123;<span class="built_in">r4</span>-<span class="built_in">r5</span>&#125;            <span class="comment">/* r5 -&gt; array_buff[1] = 0x01; r4 -&gt; array_buff[0] = 0x00; */</span></span><br><span class="line"> <span class="keyword">bx</span> <span class="built_in">lr</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">words:</span></span><br><span class="line"> <span class="meta">.word</span> <span class="number">0x00000000</span>             <span class="comment">/* words[0] */</span></span><br><span class="line"> <span class="meta">.word</span> <span class="number">0x00000001</span>             <span class="comment">/* words[1] */</span></span><br><span class="line"> <span class="meta">.word</span> <span class="number">0x00000002</span>             <span class="comment">/* words[2] */</span></span><br><span class="line"> <span class="meta">.word</span> <span class="number">0x00000003</span>             <span class="comment">/* words[3] */</span></span><br><span class="line"> <span class="meta">.word</span> <span class="number">0x00000004</span>             <span class="comment">/* words[4] */</span></span><br><span class="line"> <span class="meta">.word</span> <span class="number">0x00000005</span>             <span class="comment">/* words[5] */</span></span><br><span class="line"> <span class="meta">.word</span> <span class="number">0x00000006</span>             <span class="comment">/* words[6] */</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">array_buff_bridge:</span></span><br><span class="line"> <span class="meta">.word</span> array_buff             <span class="comment">/* address of array_buff, or in other words - array_buff[0] */</span></span><br><span class="line"> <span class="meta">.word</span> array_buff+<span class="number">8</span>           <span class="comment">/* address of array_buff[2] */</span></span><br></pre></td></tr></table></figure>

<p>在开始之前，请记住，.word 指的是 32 位 = 4 BYTES 的数据（内存）块。 这对于理解偏移很重要。 因此该程序由 .data 部分组成，我们在其中分配了一个具有 5 个元素的空数组 (array_buff)。 我们将使用它作为存储数据的可写内存位置。 .text 部分包含我们的代码以及内存操作指令和一个包含两个标签的只读数据池：一个用于具有 7 个元素的数组，另一个用于“桥接” .text 和 .data 部分，以便我们可以访问驻留的 array_buff 在 .data 部分。</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">adr</span> <span class="built_in">r0</span>, words+<span class="number">12</span>             <span class="comment">/* address of words[3] -&gt; r0 */</span></span><br></pre></td></tr></table></figure>

<p>我们使用 ADR 指令将第 4 个元素（words[3]）的地址放入 R0。 我们指向 words 数组的中间，因为我们将从那里向前和向后操作。</p>
<p>我们用 array_buff 数组的第一个 (array_buff[0]) 和第三个 (array_buff[2]) 元素的地址准备 R1 和 R2。 一旦获得地址，我们就可以开始对其进行操作。</p>
<p>下一条指令使用 LDM 从 R0 指向的内存中加载两个字值。 因此，因为我们之前让 R0 指向 words[3] 元素，所以 words[3] 值转到 R4，words[4] 值转到 R5。</p>
<p>下一条指令让我们执行 STM 指令将多个值存储到内存中。 我们代码中的 STM 指令从寄存器 R4 和 R5 获取值（0x3 和 0x4），并将这些值存储到 R1 指定的内存位置。</p>
<p>变体的类型由指令的后缀定义。 示例中使用的后缀是：-IA（之后增加）、-IB（之前增加）、-DA（之后减少）、-DB（之前减少）。 这些变体的不同之处在于它们如何访问由第一个操作数（存储源地址或目标地址的寄存器）指定的内存。 实际上，LDM 与 LDMIA 相同，这意味着每次加载后都会增加下一个要加载的元素的地址。 通过这种方式，我们从第一个操作数（存储源地址的寄存器）指定的内存地址中获得顺序（前向）数据加载。</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldmia</span> <span class="built_in">r0</span>, &#123;<span class="built_in">r4</span>-<span class="built_in">r6</span>&#125; <span class="comment">/* words[3] -&gt; r4 = 0x03, words[4] -&gt; r5 = 0x04; words[5] -&gt; r6 = 0x05; */</span> </span><br><span class="line"><span class="keyword">stmia</span> <span class="built_in">r1</span>, &#123;<span class="built_in">r4</span>-<span class="built_in">r6</span>&#125; <span class="comment">/* r4 -&gt; array_buff[0] = 0x03; r5 -&gt; array_buff[1] = 0x04; r6 -&gt; array_buff[2] = 0x05 */</span></span><br></pre></td></tr></table></figure>

<p>执行上述两条指令后，寄存器 R4-R6 和内存地址 0x000100D0、0x000100D4 和 0x000100D8 包含值 0x3、0x4 和 0x5。</p>
<p>LDMIB 指令首先将源地址增加 4 个字节（一个字值），然后执行第一次加载。 通过这种方式，我们仍然可以顺序（向前）加载数据，但第一个元素与源地址有 4 个字节的偏移量。 这就是为什么在我们的示例中，通过 LDMIB 指令从内存加载到 R4 的第一个元素是 0x00000004（word[4]）而不是 R0 指向的 0x00000003（word[3]）。</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldmib</span> <span class="built_in">r0</span>, &#123;<span class="built_in">r4</span>-<span class="built_in">r6</span>&#125;            <span class="comment">/* words[4] -&gt; r4 = 0x04; words[5] -&gt; r5 = 0x05; words[6] -&gt; r6 = 0x06 */</span></span><br><span class="line"><span class="keyword">stmib</span> <span class="built_in">r1</span>, &#123;<span class="built_in">r4</span>-<span class="built_in">r6</span>&#125;            <span class="comment">/* r4 -&gt; array_buff[1] = 0x04; r5 -&gt; array_buff[2] = 0x05; r6 -&gt; array_buff[3] = 0x06 */</span></span><br></pre></td></tr></table></figure>

<p>执行上述两条指令后，寄存器 R4-R6 和内存地址 0x100D4、0x100D8 和 0x100DC 包含值 0x4、0x5 和 0x6。</p>
<p>当我们使用 LDMDA 指令时，一切都开始向后运行。 R0 指向word[3]。 当加载开始时，我们向后移动并将word[3]、word[2]和word[1]加载到R6、R5、R4中。 是的，寄存器也是反向加载的。 所以在指令完成后 R6 = 0x00000003，R5 = 0x00000002，R4 = 0x00000001。</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldmda</span> <span class="built_in">r0</span>, &#123;<span class="built_in">r4</span>-<span class="built_in">r6</span>&#125; <span class="comment">/* words[3] -&gt; r6 = 0x03; words[2] -&gt; r5 = 0x02; words[1] -&gt; r4 = 0x01 */</span></span><br></pre></td></tr></table></figure>

<p>加载多个，递减后：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldmdb</span> <span class="built_in">r0</span>, &#123;<span class="built_in">r4</span>-<span class="built_in">r6</span>&#125; <span class="comment">/* words[2] -&gt; r6 = 0x02; words[1] -&gt; r5 = 0x01; words[0] -&gt; r4 = 0x00 */</span></span><br></pre></td></tr></table></figure>

<p>store多个，递减后：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">stmda</span> <span class="built_in">r2</span>, &#123;<span class="built_in">r4</span>-<span class="built_in">r6</span>&#125; <span class="comment">/* r6 -&gt; array_buff[2] = 0x02; r5 -&gt; array_buff[1] = 0x01; r4 -&gt; array_buff[0] = 0x00 */</span></span><br></pre></td></tr></table></figure>

<h3 id="push-and-pop"><a href="#push-and-pop" class="headerlink" title="push and pop"></a>push and pop</h3><p>PUSH：</p>
<ol>
<li>SP -= 4</li>
<li>信息store到新地址</li>
</ol>
<p>POP：</p>
<ol>
<li>SP地址处的value被load到指示的register中</li>
<li>SP += 4</li>
</ol>
<h2 id="条件执行"><a href="#条件执行" class="headerlink" title="条件执行"></a>条件执行</h2><table>
<thead>
<tr>
<th>Condition Code</th>
<th>Meaning (for cmp or subs)</th>
<th>Status of Flags</th>
</tr>
</thead>
<tbody><tr>
<td>EQ</td>
<td>Equal</td>
<td>Z==1</td>
</tr>
<tr>
<td>NE</td>
<td>Not Equal</td>
<td>Z==0</td>
</tr>
<tr>
<td>GT</td>
<td>Signed Greater Than</td>
<td>(Z==0) &amp;&amp; (N==V)</td>
</tr>
<tr>
<td>LT</td>
<td>Signed Less Than</td>
<td>N!=V</td>
</tr>
<tr>
<td>GE</td>
<td>Signed Greater Than or Equal</td>
<td>N==V</td>
</tr>
<tr>
<td>LE</td>
<td>Signed Less Than or Equal</td>
<td>(Z==1) || (N!=V)</td>
</tr>
<tr>
<td>CS or HS</td>
<td>Unsigned Higher or Same (or Carry Set)</td>
<td>C==1</td>
</tr>
<tr>
<td>CC or LO</td>
<td>Unsigned Lower (or Carry Clear)</td>
<td>C==0</td>
</tr>
<tr>
<td>MI</td>
<td>Negative (or Minus)</td>
<td>N==1</td>
</tr>
<tr>
<td>PL</td>
<td>Positive (or Plus)</td>
<td>N==0</td>
</tr>
<tr>
<td>AL</td>
<td>Always executed</td>
<td>–</td>
</tr>
<tr>
<td>NV</td>
<td>Never executed</td>
<td>–</td>
</tr>
<tr>
<td>VS</td>
<td>Signed Overflow</td>
<td>V==1</td>
</tr>
<tr>
<td>VC</td>
<td>No signed Overflow</td>
<td>V==0</td>
</tr>
<tr>
<td>HI</td>
<td>Unsigned Higher</td>
<td>(C==1) &amp;&amp; (Z==0)</td>
</tr>
<tr>
<td>LS</td>
<td>Unsigned Lower or same</td>
<td>(C==0) || (Z==0)</td>
</tr>
</tbody></table>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.global</span> main</span><br><span class="line"></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="number">#2</span>     <span class="comment">/* setting up initial variable */</span></span><br><span class="line">        <span class="keyword">cmp</span>     <span class="built_in">r0</span>, <span class="number">#3</span>     <span class="comment">/* comparing r0 to number 3. Negative bit get&#x27;s set to 1 */</span></span><br><span class="line">        <span class="keyword">addlt</span>   <span class="built_in">r0</span>, <span class="built_in">r0</span>, <span class="number">#1</span> <span class="comment">/* increasing r0 IF it was determined that it is smaller (lower than) number 3 */</span></span><br><span class="line">        <span class="keyword">cmp</span>     <span class="built_in">r0</span>, <span class="number">#3</span>     <span class="comment">/* comparing r0 to number 3 again. Zero bit gets set to 1. Negative bit is set to 0 */</span></span><br><span class="line">        <span class="keyword">addlt</span>   <span class="built_in">r0</span>, <span class="built_in">r0</span>, <span class="number">#1</span> <span class="comment">/* increasing r0 IF it was determined that it is smaller (lower than) number 3 */</span></span><br><span class="line">        <span class="keyword">bx</span>      <span class="built_in">lr</span></span><br></pre></td></tr></table></figure>

<p>上面代码中的第一条 CMP 指令触发负位被置位 (2 – 3 = -1) 表示 r0 中的值低于数字 3。随后执行 ADDLT 指令，因为当 V 时 LT 条件已满！ = N（CPSR 中溢出位和负位的值不同）。 在我们执行第二个 CMP 之前，我们的 r0 = 3。这就是为什么第二个 CMP 清除负位（因为 3 – 3 = 0，不需要设置负标志）并设置零标志（Z = 1）。 现在我们有 V = 0 和 N = 0 这导致 LT 条件失败。 因此，不会执行第二个 ADDLT，并且 r0 保持不变。 程序退出，结果为 3。</p>
<h3 id="Thumb条件执行"><a href="#Thumb条件执行" class="headerlink" title="Thumb条件执行"></a>Thumb条件执行</h3><p>在允许条件执行的 Thumb 版本 (Thumb-2)中。 某些 ARM 处理器版本支持“IT”指令，该指令允许在 Thumb 状态下有条件地执行最多 4 条指令。</p>
<p>语法：IT{x{y{z}}} cond</p>
<ol>
<li>cond 指定 IT 块中第一条指令的条件</li>
<li>x 指定 IT 块中第二条指令的条件开关</li>
<li>y 指定 IT 块中第三条指令的条件开关</li>
<li>z 指定 IT 块中第四条指令的条件开关</li>
</ol>
<p>IT 指令的结构是“IF-Then-(Else)”，语法是两个字母 T 和 E 的结构：</p>
<ol>
<li>IT 指的是 If-Then（下一条指令是有条件的）</li>
<li>ITT 指的是 If-Then-Then（接下来的 2 条指令是有条件的）</li>
<li>ITE 指的是 If-Then-Else（接下来的 2 条指令是有条件的）</li>
<li>ITTE 指的是 If-Then-Then-Else（接下来的 3 条指令是有条件的）</li>
<li>ITTEE 指的是 If-Then-Then-Else-Else（接下来的 4 条指令是有条件的）</li>
</ol>
<p>IT 块内的每条指令都必须指定一个条件后缀，该后缀相同或逻辑相反。 这意味着，如果您使用 ITE，则第一条和第二条指令 (If-Then) 必须具有相同的条件后缀，而第三条 (Else) 必须具有前两条的逻辑逆。</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ITTE</span>   NE           <span class="comment">; Next 3 instructions are conditional</span></span><br><span class="line"><span class="keyword">ANDNE</span>  <span class="built_in">R0</span>, <span class="built_in">R0</span>, <span class="built_in">R1</span>   <span class="comment">; ANDNE does not update condition flags</span></span><br><span class="line"><span class="symbol">ADDSNE</span> <span class="built_in">R2</span>, <span class="built_in">R2</span>, <span class="number">#1</span>   <span class="comment">; ADDSNE updates condition flags</span></span><br><span class="line"><span class="keyword">MOVEQ</span>  <span class="built_in">R2</span>, <span class="built_in">R3</span>       <span class="comment">; Conditional move</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ITE</span>    GT           <span class="comment">; Next 2 instructions are conditional</span></span><br><span class="line"><span class="keyword">ADDGT</span>  <span class="built_in">R1</span>, <span class="built_in">R0</span>, <span class="number">#55</span>  <span class="comment">; Conditional addition in case the GT is true</span></span><br><span class="line"><span class="keyword">ADDLE</span>  <span class="built_in">R1</span>, <span class="built_in">R0</span>, <span class="number">#48</span>  <span class="comment">; Conditional addition in case the GT is not true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ITTEE</span>  EQ           <span class="comment">; Next 4 instructions are conditional</span></span><br><span class="line"><span class="keyword">MOVEQ</span>  <span class="built_in">R0</span>, <span class="built_in">R1</span>       <span class="comment">; Conditional MOV</span></span><br><span class="line"><span class="keyword">ADDEQ</span>  <span class="built_in">R2</span>, <span class="built_in">R2</span>, <span class="number">#10</span>  <span class="comment">; Conditional ADD</span></span><br><span class="line"><span class="keyword">ANDNE</span>  <span class="built_in">R3</span>, <span class="built_in">R3</span>, <span class="number">#1</span>   <span class="comment">; Conditional AND</span></span><br><span class="line"><span class="symbol">BNE.W</span>  dloop        <span class="comment">; Branch instruction can only be used in the last instruction of an IT block</span></span><br></pre></td></tr></table></figure>

<p>以下是条件代码及其对立的条件：</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Meaning</th>
<th>Code</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>EQ</td>
<td>Equal</td>
<td>NE</td>
<td>Not Equal</td>
</tr>
<tr>
<td>HS(or CS)</td>
<td>Unsigned higher or same(or carry set)</td>
<td>LO(or CC</td>
<td>Unsigned lower(or carry clear)</td>
</tr>
<tr>
<td>MI</td>
<td>Negative</td>
<td>PL</td>
<td>Positive or Zero</td>
</tr>
<tr>
<td>VS</td>
<td>Signed Overflow</td>
<td>VC</td>
<td>No Signed Overflow</td>
</tr>
<tr>
<td>HI</td>
<td>Unsigned Higher</td>
<td>LS</td>
<td>Unsigned Lower or Same</td>
</tr>
<tr>
<td>GE</td>
<td>Signed Greater Than or Equal</td>
<td>LT</td>
<td>Signed Less Than</td>
</tr>
<tr>
<td>GT</td>
<td>Signed Greater Than</td>
<td>LE</td>
<td>Signed Less Than or Equal</td>
</tr>
<tr>
<td>AL (or omitted)</td>
<td>Always Executed</td>
<td>There is no opposite to AL</td>
<td>–</td>
</tr>
</tbody></table>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.syntax</span> unified    <span class="comment">@ this is important!</span></span><br><span class="line"><span class="symbol">.text</span></span><br><span class="line"><span class="symbol">.global</span> _start</span><br><span class="line"></span><br><span class="line"><span class="symbol">_start:</span></span><br><span class="line">    <span class="meta">.code</span> <span class="number">32</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">r3</span>, <span class="built_in">pc</span>, <span class="number">#1</span>   <span class="comment">@ increase value of PC by 1 and add it to R3</span></span><br><span class="line">    <span class="keyword">bx</span> <span class="built_in">r3</span>            <span class="comment">@ branch + exchange to the address in R3 -&gt; switch to Thumb state because LSB = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">.code</span> <span class="number">16</span>         <span class="comment">@ Thumb state</span></span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">r0</span>, <span class="number">#10</span>      </span><br><span class="line">    <span class="keyword">ite</span> eq           <span class="comment">@ if R0 is equal 10...</span></span><br><span class="line">    <span class="keyword">addeq</span> <span class="built_in">r1</span>, <span class="number">#2</span>     <span class="comment">@ ... then R1 = R1 + 2</span></span><br><span class="line">    <span class="keyword">addne</span> <span class="built_in">r1</span>, <span class="number">#3</span>     <span class="comment">@ ... else R1 = R1 + 3</span></span><br><span class="line">    bkpt</span><br></pre></td></tr></table></figure>

<p>.code 32</p>
<p>此示例代码以ARM状态开始。第一条指令将 PC 加 1 指定的地址添加到 R3，然后分支到 R3 中的地址。这将导致切换到拇指状态，因为LSB（最不重要的位）是1，因此不是4字节对齐的。为此使用bx（分支+交换）很重要。在分支之后设置T（拇指）标志，我们处于拇指状态。</p>
<p>.code 16</p>
<p>在拇指状态下，我们首先将R0与#10进行比较，这将设置负标志（0–10 = – 10）。然后我们使用If-Then-Else块。此块将跳过ADDEQ指令，因为没有设置Z（零）标志，并将执行ADDNE指令，因为结果为NE（不等于）为10。</p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><h4 id="B-BX-BLX"><a href="#B-BX-BLX" class="headerlink" title="B / BX / BLX"></a>B / BX / BLX</h4><p>存在三种类型的分支指令：</p>
<p>Branch (B)</p>
<pre><code>简单跳转到函数
</code></pre>
<p>Branch link (BL)</p>
<pre><code>在 LR 中保存 (PC+4) 并跳转到函数
</code></pre>
<p>Branch exchange (BX) and Branch link exchange (BLX)</p>
<pre><code>与 B/BL + 交换指令集相同 (ARM &lt;-&gt; Thumb)
需要一个寄存器作为第一个操作数：BX/BLX reg
</code></pre>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><table>
<thead>
<tr>
<th>Stack Type</th>
<th>Store</th>
<th>Load</th>
</tr>
</thead>
<tbody><tr>
<td>Full descending</td>
<td>STMFD (STMDB, Decrement Before)</td>
<td>LDMFD (LDM, Increment after)</td>
</tr>
<tr>
<td>Full ascending</td>
<td>STMFA (STMIB, Increment Before)</td>
<td>LDMFA (LDMDA, Decrement After)</td>
</tr>
<tr>
<td>Empty descending</td>
<td>STMED (STMDA, Decrement After)</td>
<td>LDMED (LDMIB, Increment Before)</td>
</tr>
<tr>
<td>Empty ascending</td>
<td>STMEA (STM, Increment after)</td>
<td>LDMEA (LDMDB, Decrement Before)</td>
</tr>
</tbody></table>
<p>◎ Full descending 满递减堆栈<br>堆栈首部是高地址，堆栈向低地址增长。栈指针总是指向堆栈最后一个元素(最后一个元素是最后压入的数据)。<br>ARM-Thumb过程调用标准和ARM、Thumb C/C++ 编译器总是使用Full descending 类型堆栈。</p>
<p>◎ Full ascending 满递增堆栈<br>堆栈首部是低地址，堆栈向高地址增长。栈指针总是指向堆栈最后一个元素(最后一个元素是最后压入的数据)。</p>
<p>◎ Empty descending 空递减堆栈<br>堆栈首部是低地址，堆栈向高地址增长。栈指针总是指向下一个将要放入数据的空位置。</p>
<p>◎ Empty ascending 空递增堆栈<br>堆栈首部是高地址，堆栈向低地址增长。栈指针总是指向下一个将要放入数据的空位置。</p>

	
	</div>
  <a type="button" href="/2021/08/11/Arm Instractions/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/08/03/gdb使用总结/" >gdb使用总结</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-08-03  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
		
            
            <p class="post">&lt;h1 id=&#34;gdb使用总结&#34;&gt;&lt;a href=&#34;#gdb使用总结&#34; class=&#34;headerlink&#34; title=&#34;gdb使用总结&#34;&gt;&lt;/a&gt;gdb使用总结&lt;/h1&gt;&lt;h2 id=&#34;一、编译测试程序&#34;&gt;&lt;a href=&#34;#一、编译测试程序&#34; class=&#34;headerlink&#34; title=&#34;一、编译测试程序&#34;&gt;&lt;/a&gt;一、编译测试程序&lt;/h2&gt;&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;gcc test.c -o test&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;二、从磁盘中加载二进制文件&#34;&gt;&lt;a href=&#34;#二、从磁盘中加载二进制文件&#34; class=&#34;headerlink&#34; title=&#34;二、从磁盘中加载二进制文件&#34;&gt;&lt;/a&gt;二、从磁盘中加载二进制文件&lt;/h2&gt;&lt;p&gt;方法1:&lt;/p&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;gdb --quite ./test&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;方法2:&lt;/p&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;gdb -q&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(gdb) file ./test&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;三、运行程序&#34;&gt;&lt;a href=&#34;#三、运行程序&#34; class=&#34;headerlink&#34; title=&#34;三、运行程序&#34;&gt;&lt;/a&gt;三、运行程序&lt;/h2&gt;&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(gdb) r&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;带CLI参数：&lt;/p&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(gdb) r argv[0] argv[1] ...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;运行程序并断在入口点处：&lt;/p&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(gdb) start&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;带CLI参数：&lt;/p&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(gdb) start argv[0] ...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;断点之后继续运行：&lt;/p&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(gdb)c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;四、断点操作&#34;&gt;&lt;a href=&#34;#四、断点操作&#34; class=&#34;headerlink&#34; title=&#34;四、断点操作&#34;&gt;&lt;/a&gt;四、断点操作&lt;/h2&gt;&lt;h3 id=&#34;设置断点&#34;&gt;&lt;a href=&#34;#设置断点&#34; class=&#34;headerlink&#34; title=&#34;设置断点&#34;&gt;&lt;/a&gt;设置断点&lt;/h3&gt;&lt;p&gt;有符号：&lt;/p&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(gdb) break main&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;or&lt;/p&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(gdb) b main&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;设置地址：&lt;/p&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(gdb) break *addr&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;检查断点&#34;&gt;&lt;a href=&#34;#检查断点&#34; class=&#34;headerlink&#34; title=&#34;检查断点&#34;&gt;&lt;/a&gt;检查断点&lt;/h3&gt;&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(gdb) info breakpoints&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;or&lt;/p&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(gdb) info b&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;禁用启用断点&#34;&gt;&lt;a href=&#34;#禁用启用断点&#34; class=&#34;headerlink&#34; title=&#34;禁用启用断点&#34;&gt;&lt;/a&gt;禁用启用断点&lt;/h3&gt;&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(gdb) disable num&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(gdb) enable num&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;删除断点&#34;&gt;&lt;a href=&#34;#删除断点&#34; class=&#34;headerlink&#34; title=&#34;删除断点&#34;&gt;&lt;/a&gt;删除断点&lt;/h3&gt;&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(gdb) clear *addr&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;or&lt;/p&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(gdb) clear main&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;or&lt;/p&gt;
&lt;p&gt;“delete &amp;lt;breakpoint number from info breakpoints&amp;gt;“ (short form: d)&lt;/p&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(gdb) delete 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;检查汇编代码&#34;&gt;&lt;a href=&#34;#检查汇编代码&#34; class=&#34;headerlink&#34; title=&#34;检查汇编代码&#34;&gt;&lt;/a&gt;检查汇编代码&lt;/h3&gt;&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(gdb) disassemble &amp;lt;address or symbol name&amp;gt; /r&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;bash&#34;&gt;/r显示16进制的数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
<p>
		

	

	</div>
  <a type="button" href="/2021/08/03/gdb使用总结/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h1 id="gdb使用总结"><a href="#gdb使用总结" class="headerlink" title="gdb使用总结"></a>gdb使用总结</h1><h2 id="一、编译测试程序"><a href="#一、编译测试程序" class="headerlink" title="一、编译测试程序"></a>一、编译测试程序</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o test</span><br></pre></td></tr></table></figure>

<h2 id="二、从磁盘中加载二进制文件"><a href="#二、从磁盘中加载二进制文件" class="headerlink" title="二、从磁盘中加载二进制文件"></a>二、从磁盘中加载二进制文件</h2><p>方法1:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb --quite ./test</span><br></pre></td></tr></table></figure>

<p>方法2:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb -q</span><br><span class="line">(gdb) file ./test</span><br></pre></td></tr></table></figure>

<h2 id="三、运行程序"><a href="#三、运行程序" class="headerlink" title="三、运行程序"></a>三、运行程序</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br></pre></td></tr></table></figure>

<p>带CLI参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r argv[0] argv[1] ...</span><br></pre></td></tr></table></figure>

<p>运行程序并断在入口点处：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) start</span><br></pre></td></tr></table></figure>

<p>带CLI参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) start argv[0] ...</span><br></pre></td></tr></table></figure>

<p>断点之后继续运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb)c</span><br></pre></td></tr></table></figure>

<h2 id="四、断点操作"><a href="#四、断点操作" class="headerlink" title="四、断点操作"></a>四、断点操作</h2><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p>有符号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break main</span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br></pre></td></tr></table></figure>

<p>设置地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break *addr</span><br></pre></td></tr></table></figure>

<h3 id="检查断点"><a href="#检查断点" class="headerlink" title="检查断点"></a>检查断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info breakpoints</span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info b</span><br></pre></td></tr></table></figure>

<h3 id="禁用启用断点"><a href="#禁用启用断点" class="headerlink" title="禁用启用断点"></a>禁用启用断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disable num</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) enable num</span><br></pre></td></tr></table></figure>

<h3 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear *addr</span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear main</span><br></pre></td></tr></table></figure>

<p>or</p>
<p>“delete &lt;breakpoint number from info breakpoints&gt;“ (short form: d)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete 3</span><br></pre></td></tr></table></figure>

<h3 id="检查汇编代码"><a href="#检查汇编代码" class="headerlink" title="检查汇编代码"></a>检查汇编代码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble &lt;address or symbol name&gt; /r</span><br><span class="line"><span class="meta">#</span><span class="bash">/r显示16进制的数据</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/10i &lt;addr&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">显示10条汇编</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) display/10i &lt;instruction pointer / program counter&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">On x86 systems &lt;instruction pointer / program counter&gt; would be <span class="variable">$rip</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">On ARM systems &lt;instruction pointer / program counter&gt; would be <span class="variable">$pc</span></span></span><br></pre></td></tr></table></figure>

<h3 id="监视断点"><a href="#监视断点" class="headerlink" title="监视断点"></a>监视断点</h3><h4 id="只写断点"><a href="#只写断点" class="headerlink" title="只写断点"></a>只写断点</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) watch &lt;address&gt;</span><br></pre></td></tr></table></figure>

<h4 id="只读断点"><a href="#只读断点" class="headerlink" title="只读断点"></a>只读断点</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) rwatch &lt;address&gt;</span><br></pre></td></tr></table></figure>

<h4 id="读写断点"><a href="#读写断点" class="headerlink" title="读写断点"></a>读写断点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awatch &lt;address&gt;</span><br></pre></td></tr></table></figure>

<h4 id="设置访问断点的大小"><a href="#设置访问断点的大小" class="headerlink" title="设置访问断点的大小"></a>设置访问断点的大小</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) watch *(char *) &lt;address&gt; </span><br><span class="line"><span class="meta">#</span><span class="bash">would <span class="built_in">set</span> a watchpoint to <span class="built_in">break</span> on access to the one byte at &lt;address&gt;, and therefore wouldn\<span class="string">&#x27;t fire if address+2 was written to. Whereas</span></span></span><br><span class="line"></span><br><span class="line">(gdb )watch *(long long *) &lt;address&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">would fire if any of the 8 bytes starting at &lt;address&gt; were written to.</span></span></span><br></pre></td></tr></table></figure>

<h3 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h3><p>使用”hbreak” 命令 (short form: hb) 用法与break相似</p>
<h2 id="检查-修改数据"><a href="#检查-修改数据" class="headerlink" title="检查/修改数据"></a>检查/修改数据</h2><p>Commands: x (examine), print, display</p>
<p>格式化输出：<br>后边跟/nFMT</p>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">10.5 Output Formats</span><br><span class="line"></span><br><span class="line">By default, GDB prints a value according to its data type. Sometimes this is not what you want. For example, you might want to print a number in hex, or a pointer in decimal. Or you might want to view data in memory at a certain address as a character string or as an instruction. To do these things, specify an output format when you print a value.</span><br><span class="line"></span><br><span class="line">The simplest use of output formats is to say how to print a value already computed. This is done by starting the arguments of the print command with a slash and a format letter. The format letters supported are:</span><br><span class="line"></span><br><span class="line">x</span><br><span class="line">Regard the bits of the value as an integer, and print the integer in hexadecimal.</span><br><span class="line"></span><br><span class="line">d</span><br><span class="line">Print as integer in signed decimal.</span><br><span class="line"></span><br><span class="line">u</span><br><span class="line">Print as integer in unsigned decimal.</span><br><span class="line"></span><br><span class="line">o</span><br><span class="line">Print as integer in octal.</span><br><span class="line"></span><br><span class="line">t</span><br><span class="line">Print as integer in binary. The letter ‘t’ stands for “two”. 11</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">Print as an address, both absolute in hexadecimal and as an offset from the nearest preceding symbol. You can use this format used to discover where (in what function) an unknown address is located:</span><br><span class="line"></span><br><span class="line">(gdb) p/a 0x54320</span><br><span class="line">$3 = 0x54320 <span class="xml">&lt;_initialize_vx+396&gt;</span></span><br><span class="line">The command info symbol 0x54320 yields similar results. See info symbol.</span><br><span class="line"></span><br><span class="line">c</span><br><span class="line">Regard as an integer and print it as a character constant. This prints both the numerical value and its character representation. The character representation is replaced with the octal escape ‘\nnn’ for characters outside the 7-bit ASCII range.</span><br><span class="line"></span><br><span class="line">Without this format, GDB displays char, unsigned char, and signed char data as character constants. Single-byte members of vectors are displayed as integer data.</span><br><span class="line"></span><br><span class="line">f</span><br><span class="line">Regard the bits of the value as a floating point number and print using typical floating point syntax.</span><br><span class="line"></span><br><span class="line">s</span><br><span class="line">Regard as a string, if possible. With this format, pointers to single-byte data are displayed as null-terminated strings and arrays of single-byte data are displayed as fixed-length strings. Other values are displayed in their natural types.</span><br><span class="line"></span><br><span class="line">Without this format, GDB displays pointers to and arrays of char, unsigned char, and signed char as strings. Single-byte members of a vector are displayed as an integer array.</span><br><span class="line"></span><br><span class="line">z</span><br><span class="line">Like ‘x’ formatting, the value is treated as an integer and printed as hexadecimal, but leading zeros are printed to pad the value to the size of the integer type.</span><br><span class="line"></span><br><span class="line">r</span><br><span class="line">Print using the ‘raw’ formatting. By default, GDB will use a Python-based pretty-printer, if one is available (see Pretty Printing). This typically results in a higher-level display of the value’s contents. The ‘r’ format bypasses any Python pretty-printer which might exist.</span><br><span class="line"></span><br><span class="line">For example, to print the program counter in hex (see Registers), type</span><br><span class="line"></span><br><span class="line">p/x $pc</span><br><span class="line">Note that no space is required before the slash; this is because command names in GDB cannot contain a slash.</span><br><span class="line"></span><br><span class="line">To reprint the last value in the value history with a different format, you can use the print command with just a format and no expression. For example, ‘p/x’ reprints the last value in hex.</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html">FMT</a></p>
<h3 id="检查寄存器"><a href="#检查寄存器" class="headerlink" title="检查寄存器"></a>检查寄存器</h3><p>info r rax rbx rbp</p>
<p>也可以使用print(short form:p)结合/FMT，进行格式化输出</p>
<h3 id="修改寄存器"><a href="#修改寄存器" class="headerlink" title="修改寄存器"></a>修改寄存器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set $rax = 0xdeadbeeff00dface</span><br><span class="line">(gdb) p/x $rax</span><br><span class="line"><span class="meta">$</span><span class="bash">15 = 0xdeadbeeff00dface</span></span><br><span class="line">(gdb) set $ax = 0xcafef00d</span><br><span class="line">(gdb) p/x $rax</span><br><span class="line"><span class="meta">$</span><span class="bash">16 = 0xdeadbeeff00df00d</span></span><br></pre></td></tr></table></figure>

<h3 id="检查内存"><a href="#检查内存" class="headerlink" title="检查内存"></a>检查内存</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">The <span class="string">&quot;x&quot;</span> <span class="built_in">command</span> (<span class="keyword">for</span> examine memory) supports the /FMT specifier.</span></span><br><span class="line">(gdb) x/8xb $rsp</span><br><span class="line">0x7fffffffe038: 0xb3 0xd0 0xde 0xf7 0xff 0x7f 0x00 0x00</span><br><span class="line">(gdb) x/4xh $rsp</span><br><span class="line">0x7fffffffe038: 0xd0b3 0xf7de 0x7fff 0x0000</span><br><span class="line">(gdb) x/2xw $rsp</span><br><span class="line">0x7fffffffe038: 0xf7ded0b3 0x00007fff</span><br><span class="line">(gdb) x/1xg $rsp</span><br><span class="line">0x7fffffffe038: 0x00007ffff7ded0b3</span><br><span class="line">(gdb) x/s 0x555555556008</span><br><span class="line">0x555555556008: &quot;First %d elements of the Fibbonacci sequence: &quot;</span><br><span class="line">(gdb) x/3i $rip</span><br><span class="line">=&gt; 0x5555555551a9 &lt;main&gt;: endbr64 </span><br><span class="line">   0x5555555551ad &lt;main+4&gt;: push   %rbp</span><br><span class="line">   0x5555555551ae &lt;main+5&gt;: mov    %rsp,%rbp</span><br></pre></td></tr></table></figure>

<h3 id="修改内存"><a href="#修改内存" class="headerlink" title="修改内存"></a>修改内存</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> (gdb) x/1xg $rsp</span><br><span class="line">0x7fffffffe038: 0x00007ffff7ded0b3</span><br><span class="line">(gdb) set &#123;char&#125;$rsp = 0xFF</span><br><span class="line">(gdb) x/1xg $rsp</span><br><span class="line">0x7fffffffe038: 0x00007ffff7ded0ff</span><br><span class="line">(gdb) set &#123;short&#125;$rsp = 0xFF</span><br><span class="line">(gdb) x/1xg $rsp</span><br><span class="line">0x7fffffffe038: 0x00007ffff7de00ff</span><br><span class="line">(gdb) set &#123;short&#125;$rsp = 0xFFFF</span><br><span class="line">(gdb) x/1xg $rsp</span><br><span class="line">0x7fffffffe038: 0x00007ffff7deffff</span><br><span class="line">(gdb) set &#123;long long&#125;$rsp = 0x1337bee7</span><br><span class="line">(gdb) x/1xg $rsp</span><br><span class="line">0x7fffffffe038: 0x000000001337bee7</span><br></pre></td></tr></table></figure>

<h3 id="栈回溯"><a href="#栈回溯" class="headerlink" title="栈回溯"></a>栈回溯</h3><p><a target="_blank" rel="noopener" href="https://sourceware.org/gdb/current/onlinedocs/gdb/Backtrace.html#Backtrace">bt</a></p>
<h2 id="五、单步运行"><a href="#五、单步运行" class="headerlink" title="五、单步运行"></a>五、单步运行</h2><p>单步步过：ni<br>单步步入：si<br>单步步出：finish(short form:fin)</p>
<p>运行到某个地址：until &lt;address&gt;</p>
<h2 id="六、附加运行"><a href="#六、附加运行" class="headerlink" title="六、附加运行"></a>六、附加运行</h2><p>依赖于你的系统安全设置支不支持ptrace的系统调用，你也许不能附加到进程上，尽管你们使用的是相同的用户。你也可以使用root权限运行gdb，或者使用下述命令去禁用掉这个安全选项。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</span><br></pre></td></tr></table></figure>

<p>Remembering to re-restrict access when done via:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 | sudo tee /proc/sys/kernel/yama/ptrace_scope</span><br></pre></td></tr></table></figure>

<p>attach &lt;process ID&gt;</p>
<h2 id="七、杂项配置"><a href="#七、杂项配置" class="headerlink" title="七、杂项配置"></a>七、杂项配置</h2><p>可以在gdb中使用下述命令修改gdb的汇编语言的类型到Intel或者AT&amp;T：</p>
<p>set disassembly-flavor intel<br>set disassembly-flavor att</p>
<h2 id="八、gdb的命令行文件"><a href="#八、gdb的命令行文件" class="headerlink" title="八、gdb的命令行文件"></a>八、gdb的命令行文件</h2><p>有时候想要让他在启动gdb时就自动运行一些命令，可以使用脚本，gdb启动时加上 -x 指定脚本文件 就可以了。</p>

	
	</div>
  <a type="button" href="/2021/08/03/gdb使用总结/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/08/01/pwn总结/" >pwn总结</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-08-01  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
		
            
            <p class="post">&lt;h2 id=&#34;栈溢出&#34;&gt;&lt;a href=&#34;#栈溢出&#34; class=&#34;headerlink&#34; title=&#34;栈溢出&#34;&gt;&lt;/a&gt;栈溢出&lt;/h2&gt;&lt;h3 id=&#34;过NX&#34;&gt;&lt;a href=&#34;#过NX&#34; class=&#34;headerlink&#34; title=&#34;过NX&#34;&gt;&lt;/a&gt;过NX&lt;/h3&gt;&lt;p&gt;No-eXecute，表示不可执行，其原理是将数据所在的内存页标识为不可执行，如果程序产生溢出转入执行 shellcode 时，CPU 会抛出异常。&lt;/p&gt;
&lt;p&gt;在 Linux 中，当装载器将程序装载进内存空间后，将程序的 .text 段标记为可执行，而其余的数据段（.data、.bss 等）以及栈、堆均为不可执行。因此，传统利用方式中通过修改 GOT 来执行 shellcode 的方式不再可行。&lt;/p&gt;
&lt;p&gt;使用ROP，ret2libc&lt;/p&gt;
&lt;h3 id=&#34;过PIE，ASLR&#34;&gt;&lt;a href=&#34;#过PIE，ASLR&#34; class=&#34;headerlink&#34; title=&#34;过PIE，ASLR&#34;&gt;&lt;/a&gt;过PIE，ASLR&lt;/h3&gt;&lt;p&gt;地址空间布局随机化（ASLR），该技术虽然不是由 GCC 编译时提供的，但对 PIE 还是有影响。该技术旨在将程序的内存布局随机化，使得攻击者不能轻易地得到数据区的地址来构造 payload。由于程序的堆栈分配与共享库的装载都是在运行时进行，系统在程序每次执行时，随机地分配程序堆栈的地址以及共享库装载的地址。使得攻击者无法预测自己写入的数据区的虚拟地址。&lt;/p&gt;
&lt;p&gt;针对该保护机制的攻击，往往是通过信息泄漏来实现。由于同一模块中的所有代码和数据的相对偏移是固定的，攻击者只要泄漏出某个模块中的任一代码指针或数据指针，即可通过计算得到此模块中任意代码或数据的地址。&lt;/p&gt;
&lt;p&gt;PIE（Position Independent Executable）其实就是把可执行文件给编译成动态链接库，需要配合 ASLR 来使用，以达到可执行文件的加载时地址随机化。简单来说，PIE 是编译时随机化，由编译器完成；ASLR 是加载时随机化，由操作系统完成。ASLR 将程序运行时的堆栈以及共享库的加载地址随机化，而 PIE 在编译时将程序编译为位置无关、即程序运行时各个段加载的虚拟地址在装载时确定。开启 PIE 时，编译生成的是动态库文件（Shared object）文件，而关闭 PIE 后生成可执行文件（Executable）&lt;/p&gt;
&lt;p&gt;需要把地址泄漏出来&lt;/p&gt;
&lt;h3 id=&#34;过canary&#34;&gt;&lt;a href=&#34;#过canary&#34; class=&#34;headerlink&#34; title=&#34;过canary&#34;&gt;&lt;/a&gt;过canary&lt;/h3&gt;&lt;p&gt;-fno-stack-protector 关闭canary检测&lt;br&gt;-fstack-protector 打开canary检测&lt;/p&gt;
&lt;p&gt;通过泄漏地址或者&lt;/p&gt;
&lt;h3 id=&#34;RELRO&#34;&gt;&lt;a href=&#34;#RELRO&#34; class=&#34;headerlink&#34; title=&#34;RELRO&#34;&gt;&lt;/a&gt;RELRO&lt;/h3&gt;&lt;p&gt;RELRO（ReLocation Read-Only）设置符号重定向表为只读或在程序启动时就解析并绑定所有动态符号，从而减少对 GOT（Global Offset Table）的攻击。&lt;/p&gt;
&lt;p&gt;RELOR 有两种形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Partial RELRO：一些段（包括 &lt;code&gt;.dynamic&lt;/code&gt;）在初始化后将会被标记为只读。&lt;/li&gt;
&lt;li&gt;Full RELRO：除了 Partial RELRO，延迟绑定将被禁止，所有的导入符号将在开始时被解析，&lt;code&gt;.got.plt&lt;/code&gt; 段会被完全初始化为目标函数的最终地址，并被标记为只读。另外 &lt;code&gt;link_map&lt;/code&gt; 和 &lt;code&gt;_dl_runtime_resolve&lt;/code&gt; 的地址也不会被装入。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编译参数&#34;&gt;&lt;a href=&#34;#编译参数&#34; class=&#34;headerlink&#34; title=&#34;编译参数&#34;&gt;&lt;/a&gt;编译参数&lt;/h2&gt;&lt;p&gt;各种安全技术的编译参数如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;安全技术&lt;/th&gt;
&lt;th&gt;完全开启&lt;/th&gt;
&lt;th&gt;部分开启&lt;/th&gt;
&lt;th&gt;关闭&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Canary&lt;/td&gt;
&lt;td&gt;-fstack-protector-all&lt;/td&gt;
&lt;td&gt;-fstack-protector&lt;/td&gt;
&lt;td&gt;-fno-stack-protector&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NX&lt;/td&gt;
&lt;td&gt;-z noexecstack&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-z execstack&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PIE&lt;/td&gt;
&lt;td&gt;-pie&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-no-pie&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RELRO&lt;/td&gt;
&lt;td&gt;-z now&lt;/td&gt;
&lt;td&gt;-z lazy&lt;/td&gt;
&lt;td&gt;-z norelro&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
<p>
		

	

	</div>
  <a type="button" href="/2021/08/01/pwn总结/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><h3 id="过NX"><a href="#过NX" class="headerlink" title="过NX"></a>过NX</h3><p>No-eXecute，表示不可执行，其原理是将数据所在的内存页标识为不可执行，如果程序产生溢出转入执行 shellcode 时，CPU 会抛出异常。</p>
<p>在 Linux 中，当装载器将程序装载进内存空间后，将程序的 .text 段标记为可执行，而其余的数据段（.data、.bss 等）以及栈、堆均为不可执行。因此，传统利用方式中通过修改 GOT 来执行 shellcode 的方式不再可行。</p>
<p>使用ROP，ret2libc</p>
<h3 id="过PIE，ASLR"><a href="#过PIE，ASLR" class="headerlink" title="过PIE，ASLR"></a>过PIE，ASLR</h3><p>地址空间布局随机化（ASLR），该技术虽然不是由 GCC 编译时提供的，但对 PIE 还是有影响。该技术旨在将程序的内存布局随机化，使得攻击者不能轻易地得到数据区的地址来构造 payload。由于程序的堆栈分配与共享库的装载都是在运行时进行，系统在程序每次执行时，随机地分配程序堆栈的地址以及共享库装载的地址。使得攻击者无法预测自己写入的数据区的虚拟地址。</p>
<p>针对该保护机制的攻击，往往是通过信息泄漏来实现。由于同一模块中的所有代码和数据的相对偏移是固定的，攻击者只要泄漏出某个模块中的任一代码指针或数据指针，即可通过计算得到此模块中任意代码或数据的地址。</p>
<p>PIE（Position Independent Executable）其实就是把可执行文件给编译成动态链接库，需要配合 ASLR 来使用，以达到可执行文件的加载时地址随机化。简单来说，PIE 是编译时随机化，由编译器完成；ASLR 是加载时随机化，由操作系统完成。ASLR 将程序运行时的堆栈以及共享库的加载地址随机化，而 PIE 在编译时将程序编译为位置无关、即程序运行时各个段加载的虚拟地址在装载时确定。开启 PIE 时，编译生成的是动态库文件（Shared object）文件，而关闭 PIE 后生成可执行文件（Executable）</p>
<p>需要把地址泄漏出来</p>
<h3 id="过canary"><a href="#过canary" class="headerlink" title="过canary"></a>过canary</h3><p>-fno-stack-protector 关闭canary检测<br>-fstack-protector 打开canary检测</p>
<p>通过泄漏地址或者</p>
<h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><p>RELRO（ReLocation Read-Only）设置符号重定向表为只读或在程序启动时就解析并绑定所有动态符号，从而减少对 GOT（Global Offset Table）的攻击。</p>
<p>RELOR 有两种形式：</p>
<ul>
<li>Partial RELRO：一些段（包括 <code>.dynamic</code>）在初始化后将会被标记为只读。</li>
<li>Full RELRO：除了 Partial RELRO，延迟绑定将被禁止，所有的导入符号将在开始时被解析，<code>.got.plt</code> 段会被完全初始化为目标函数的最终地址，并被标记为只读。另外 <code>link_map</code> 和 <code>_dl_runtime_resolve</code> 的地址也不会被装入。</li>
</ul>
<h2 id="编译参数"><a href="#编译参数" class="headerlink" title="编译参数"></a>编译参数</h2><p>各种安全技术的编译参数如下：</p>
<table>
<thead>
<tr>
<th>安全技术</th>
<th>完全开启</th>
<th>部分开启</th>
<th>关闭</th>
</tr>
</thead>
<tbody><tr>
<td>Canary</td>
<td>-fstack-protector-all</td>
<td>-fstack-protector</td>
<td>-fno-stack-protector</td>
</tr>
<tr>
<td>NX</td>
<td>-z noexecstack</td>
<td></td>
<td>-z execstack</td>
</tr>
<tr>
<td>PIE</td>
<td>-pie</td>
<td></td>
<td>-no-pie</td>
</tr>
<tr>
<td>RELRO</td>
<td>-z now</td>
<td>-z lazy</td>
<td>-z norelro</td>
</tr>
</tbody></table>

	
	</div>
  <a type="button" href="/2021/08/01/pwn总结/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/07/23/x64内核研究(IA-32e模式)/" >x64内核研究（IA-32e模式）</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-07-23  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
		
            
            <p class="post">&lt;h2 id=&#34;IA-32e模式&#34;&gt;&lt;a href=&#34;#IA-32e模式&#34; class=&#34;headerlink&#34; title=&#34;IA-32e模式&#34;&gt;&lt;/a&gt;IA-32e模式&lt;/h2&gt;&lt;p&gt;IA-32e模式：内核64位，用户64位或32位 强制平坦段，不支持任务切换…&lt;/p&gt;
&lt;p&gt;Legacy模式：内核32位，用户32位支持非平坦段，任务切换，虚拟8086，实模式等。&lt;/p&gt;
&lt;p&gt;IA-32e: 代码段，数据段仍使用64位描述符，强制平坦(FS，GS除外)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.TSS段描述符扩展到128位
2.TSS段不用来任务切换，主要保存一堆rsp备用指针
3.中断门描述符扩展到128位
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;IA32_EFER MSR C0000080H&lt;/p&gt;
&lt;p&gt;IA32_FS_BASE C0000100H&lt;/p&gt;
&lt;p&gt;IA32_GS_BASE C0000101H&lt;/p&gt;
&lt;p&gt;IA32_KERNEl_GS_BASE C0000102H&lt;/p&gt;
&lt;p&gt;权限切换&lt;/p&gt;
&lt;p&gt;系统切换：只使用一张SSDT表，x64用户程序通过syscall进入内核 x86用户程序在ring3转入x64模式再进入内核&lt;/p&gt;
&lt;p&gt;中断：只使用一张idt表，内核可以根据栈上的保存的cs判断先前模式&lt;/p&gt;
&lt;h2 id=&#34;SMAP-和-SMEP&#34;&gt;&lt;a href=&#34;#SMAP-和-SMEP&#34; class=&#34;headerlink&#34; title=&#34;SMAP 和 SMEP&#34;&gt;&lt;/a&gt;SMAP 和 SMEP&lt;/h2&gt;&lt;p&gt;SMAP(Supervisor Mode Access Prevention，管理模式访问保护)和SMEP(Supervisor Mode Execution Prevention，管理模式执行保护)的作用分别是禁止内核CPU访问用户空间的数据和执行用户空间的代码，并不会因为你权限高就能访问/执行低权限的资源，你的就是你的，我的就是我的，而之前零环权限就很牛逼了，你的就是我的，我的还是我的。&lt;/p&gt;
&lt;h2 id=&#34;分页&#34;&gt;&lt;a href=&#34;#分页&#34; class=&#34;headerlink&#34; title=&#34;分页&#34;&gt;&lt;/a&gt;分页&lt;/h2&gt;&lt;p&gt;四级页表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;PXE&lt;/th&gt;
&lt;th&gt;PPE&lt;/th&gt;
&lt;th&gt;PDE&lt;/th&gt;
&lt;th&gt;PTE&lt;/th&gt;
&lt;th&gt;物理页面&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;Patch-Guard&#34;&gt;&lt;a href=&#34;#Patch-Guard&#34; class=&#34;headerlink&#34; title=&#34;Patch Guard&#34;&gt;&lt;/a&gt;Patch Guard&lt;/h2&gt;&lt;p&gt;绝大部分 PG 检测基于context结构体；&lt;br&gt;context包括：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一小段自解密代码要用到的系统api指针
重要的api代码copy
INITKDBG节的copy，
要检测的目标地址，大小，chucksum构成的结构体数组
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;context大部分时间是加密的；&lt;/p&gt;
&lt;p&gt;context的数据来自与系统初始化时的最初数据；&lt;/p&gt;
&lt;p&gt;context的地址，作为系统线程，DPC等的参数，随着调度被传递；&lt;/p&gt;
&lt;p&gt;context的验证逻辑执行周期约为2min，但每次检测的目标区块随机；&lt;/p&gt;
&lt;p&gt;context采用接力的方式调度，自解密-&amp;gt;检测逻辑-&amp;gt;复制自身到新的context-&amp;gt;加密新的context-&amp;gt;销毁旧的context；&lt;/p&gt;
&lt;p&gt;context-&amp;gt;检测逻辑的调用源有随机性，在PG初始化1时决定。&lt;/p&gt;
&lt;p&gt;攻击手法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.静态补丁
2.VT实现 读/执行 分离
<p>
		

	

	</div>
  <a type="button" href="/2021/07/23/x64内核研究(IA-32e模式)/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="IA-32e模式"><a href="#IA-32e模式" class="headerlink" title="IA-32e模式"></a>IA-32e模式</h2><p>IA-32e模式：内核64位，用户64位或32位 强制平坦段，不支持任务切换…</p>
<p>Legacy模式：内核32位，用户32位支持非平坦段，任务切换，虚拟8086，实模式等。</p>
<p>IA-32e: 代码段，数据段仍使用64位描述符，强制平坦(FS，GS除外)</p>
<pre><code>1.TSS段描述符扩展到128位
2.TSS段不用来任务切换，主要保存一堆rsp备用指针
3.中断门描述符扩展到128位
</code></pre>
<p>IA32_EFER MSR C0000080H</p>
<p>IA32_FS_BASE C0000100H</p>
<p>IA32_GS_BASE C0000101H</p>
<p>IA32_KERNEl_GS_BASE C0000102H</p>
<p>权限切换</p>
<p>系统切换：只使用一张SSDT表，x64用户程序通过syscall进入内核 x86用户程序在ring3转入x64模式再进入内核</p>
<p>中断：只使用一张idt表，内核可以根据栈上的保存的cs判断先前模式</p>
<h2 id="SMAP-和-SMEP"><a href="#SMAP-和-SMEP" class="headerlink" title="SMAP 和 SMEP"></a>SMAP 和 SMEP</h2><p>SMAP(Supervisor Mode Access Prevention，管理模式访问保护)和SMEP(Supervisor Mode Execution Prevention，管理模式执行保护)的作用分别是禁止内核CPU访问用户空间的数据和执行用户空间的代码，并不会因为你权限高就能访问/执行低权限的资源，你的就是你的，我的就是我的，而之前零环权限就很牛逼了，你的就是我的，我的还是我的。</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>四级页表</p>
<table>
<thead>
<tr>
<th>PXE</th>
<th>PPE</th>
<th>PDE</th>
<th>PTE</th>
<th>物理页面</th>
</tr>
</thead>
<tbody><tr>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>12</td>
</tr>
</tbody></table>
<h2 id="Patch-Guard"><a href="#Patch-Guard" class="headerlink" title="Patch Guard"></a>Patch Guard</h2><p>绝大部分 PG 检测基于context结构体；<br>context包括：</p>
<pre><code>一小段自解密代码要用到的系统api指针
重要的api代码copy
INITKDBG节的copy，
要检测的目标地址，大小，chucksum构成的结构体数组
...
</code></pre>
<p>context大部分时间是加密的；</p>
<p>context的数据来自与系统初始化时的最初数据；</p>
<p>context的地址，作为系统线程，DPC等的参数，随着调度被传递；</p>
<p>context的验证逻辑执行周期约为2min，但每次检测的目标区块随机；</p>
<p>context采用接力的方式调度，自解密-&gt;检测逻辑-&gt;复制自身到新的context-&gt;加密新的context-&gt;销毁旧的context；</p>
<p>context-&gt;检测逻辑的调用源有随机性，在PG初始化1时决定。</p>
<p>攻击手法：</p>
<pre><code>1.静态补丁
2.VT实现 读/执行 分离
3.定位所有的context调用源，针对性patch
4.基于加密算法分析，攻击context的内容
    (1) 搜索内存，粗筛context；
    (2)基于加密算法特征，定位context；
    (3)解密context，patch检测逻辑，加密写回context

5.设置context页面不可执行，接管页面异常处理
    (1)搜索内存，粗筛context；
    (2)hook PageFault，接管执行保护异常；
    (3)在异常处理中定位context，阻止检测逻辑。
</code></pre>

	
	</div>
  <a type="button" href="/2021/07/23/x64内核研究(IA-32e模式)/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/07/21/驱动的运行/" >驱动的运行</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-07-21  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/07/21/驱动的运行/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="cmd启动"><a href="#cmd启动" class="headerlink" title="cmd启动"></a>cmd启动</h2><p>注册驱动</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc create ServiceName binPath= &quot;C:\xxx.sys&quot; <span class="built_in">type</span>= kernel <span class="built_in">start</span>= demand</span><br></pre></td></tr></table></figure>

<p>sc create 表示创建一个服务， binPath 指驱动路径，type 表示驱动类型， start 表示启动类型。demand表示手动启动</p>
<p>启动服务</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc <span class="built_in">start</span> ServiceName</span><br></pre></td></tr></table></figure>

<p>停止服务</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc stop ServiceName</span><br></pre></td></tr></table></figure>

<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc delete ServiceName</span><br></pre></td></tr></table></figure>

<h2 id="API启动"><a href="#API启动" class="headerlink" title="API启动"></a>API启动</h2><h3 id="step1-打开服务管理器"><a href="#step1-打开服务管理器" class="headerlink" title="step1 打开服务管理器"></a>step1 打开服务管理器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SC_HANDLE <span class="title">OpenSCManagerA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpMachineName,     <span class="comment">//字符串常量，表示机器的名字，NULL表示打开的是本机的服务管理器。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpDatabaseName,    <span class="comment">//字符串常量，表示数据库的名字，NULL表示是一个活动数据库。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  dwDesiredAccess    <span class="comment">//DWORD类型的值，表示权限，SC_MANAGER_ALL_ACCESS (0xF003F)表示一切权限，SC_MANAGER_CREATE_SERVICE (0x0002)创建服务的权限，SC_MANAGER_ENUMERATE_SERVICE (0x0004)枚举服务的权限......</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个SC_HANDLE的句柄</span></span><br></pre></td></tr></table></figure>

<h3 id="step2-服务的注册"><a href="#step2-服务的注册" class="headerlink" title="step2 服务的注册"></a>step2 服务的注册</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SC_HANDLE <span class="title">CreateService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SC_HANDLE hSCManager,         <span class="comment">//服务管理器的句柄（必须具有SC_MANAGER_CREATE_SERVICE权限）</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpServiceName,      <span class="comment">//服务的名字，不能重名</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpDisplayName,      <span class="comment">//显示的名字</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwDesiredAccess,    <span class="comment">//服务的权限，SERVICE_START,SERVICE_STOP,SERVICE_QUERY_STATUS,SERVICE_ALL_ACCESS</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwServiceType,      <span class="comment">//表示创建何种服务服务的类型有 SERVICE_FILE_SYSTEM_DRIVER、SERVICE_KERNEL_DRIVER、SERVICE_WIN32_OWN_PROCESS、SERVICE_WIN32_SHARE_PROCESS</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwStartType,        <span class="comment">//服务的启动方式，SERVICE_BOOT_START（OS引导阶段启动的服务，由Winload模块负责）、SERVICE_SYSTEM_START（OS启动阶段启动的服务，由NT模块负责）、SERVICE_AUTO_START（OS启动完毕后启动的）、SERVICE_DEMAND_START（手动启动的服务）</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwErrorControl,     <span class="comment">//错误控制，具体指服务启动失败的情况下，操作系统需要执行何种操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpBinaryPathName,   <span class="comment">//可执行文件的全路径</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpLoadOrderGroup,   <span class="comment">//服务所在的分组名字NULL即可</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD   lpdwTagId,          <span class="comment">//与服务的加载顺序相关，0即可</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpDependencies,     <span class="comment">//表示该服务依赖的其他服务名的列表</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpServiceStartName, <span class="comment">//服务以什么用户身份启动，内核驱动设置为NULL即可</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpPassword          <span class="comment">//同lpServiceStartName</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>打开已注册的服务</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SC_HANDLE <span class="title">OpenService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SC_HANDLE hSCManager,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpServiceName,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwDesiredAccess</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="step3-启动服务"><a href="#step3-启动服务" class="headerlink" title="step3 启动服务"></a>step3 启动服务</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">StartService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SC_HANDLE hService,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwNumServiceArgs,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    *lpServiceArgVectors</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>停止暂停恢复服务：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ControlService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SC_HANDLE        hService,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD            dwControl,   <span class="comment">//SERVICE_CONTROL_PAUSE、SERVICE_CONTROL_STOP、SERVICE_CONTROL_CONTINUE......</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSERVICE_STATUS lpServiceStatus</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="step4-删除服务"><a href="#step4-删除服务" class="headerlink" title="step4 删除服务"></a>step4 删除服务</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeleteService</span><span class="params">(SC_HANDLE hService)</span></span></span><br></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2021/07/21/驱动的运行/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/07/13/afl/" >afl初探</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-07-13  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/07/13/afl/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="模糊测试六步骤"><a href="#模糊测试六步骤" class="headerlink" title="模糊测试六步骤"></a>模糊测试六步骤</h2><p>1.识别目标系统</p>
<p>2.确定输入</p>
<p>3.生成模糊数据</p>
<p>4.使用模糊数据进行测试</p>
<p>5.监控系统的行为</p>
<p>6.记录缺陷</p>
<h2 id="afl-fuzz"><a href="#afl-fuzz" class="headerlink" title="afl-fuzz"></a>afl-fuzz</h2><p>最近在研究afl-fuzz，发现一些有意思的东西，记录一下。</p>
<p>先说这个afl-fuzz的打桩机制，越想越觉得作者这人脑回路新奇。先说说使用这个方法的初衷。</p>
<p>为了提升性能，afl-fuzz使用了一个”fork server”，fuzz的进程只进行一次execve(), 连接(linking), 库初始化(libc initialization)。fuzz进程通过copy-on-write的方式从已停止的fuzz进程中clone下来。</p>
<p>为了实现copy-on-write功能，作者在编译的时候把初始化操作插入到程序的最开始，把编译后的程序拖到IDA会发现文件格式的DT_INIT_ARRAY里被添加了几个名字带有afl的函数，这几个函数会在程序加载完后先执行，（先于main函数），程序会在这里进行fork()子进程的操作。等待afl-fuzz的命令，接受子进程的状态，并发送给afl-fuzz。</p>

	
	</div>
  <a type="button" href="/2021/07/13/afl/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/07/06/散列/" >散列函数</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-07-06  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/07/06/散列/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="散列函数的优劣标准"><a href="#散列函数的优劣标准" class="headerlink" title="散列函数的优劣标准"></a>散列函数的优劣标准</h2><p>1.确定（dederminism）同一关键码总是被映射至同一地址。</p>
<p>2.快速（effciency）expeced - o(1)</p>
<p>3.满射（surjection）尽可能充分覆盖整个散列空间。</p>
<p>4.均匀（uniformity）关键码映射散列表各位置的概率尽量接近可有效避免聚集（clustering）现象。</p>
<h2 id="散列函数的选择"><a href="#散列函数的选择" class="headerlink" title="散列函数的选择"></a>散列函数的选择</h2><h3 id="整除取余法"><a href="#整除取余法" class="headerlink" title="整除取余法"></a>整除取余法</h3><h3 id="MAD法"><a href="#MAD法" class="headerlink" title="MAD法"></a>MAD法</h3><p>除余法的缺陷：</p>
<pre><code>1）不动点。无论表长取值如何，总有hash(0) = 0;
2）零阶均匀。[0,R)的关键码，平均分配至M个桶，但相邻关键码的散列必定相邻。
</code></pre>
<p>取M为素数：hash(key) = (a * key + b) % M</p>
<h3 id="平方取中"><a href="#平方取中" class="headerlink" title="平方取中"></a>平方取中</h3><p>取平方的中间若干位</p>
<h3 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h3><p>hash(123456789) = 123 + 456 + 789<br>hash(123456789) = 123 + 654 + 789</p>
<h3 id="位异或法"><a href="#位异或法" class="headerlink" title="位异或法"></a>位异或法</h3><p>hash(101011001) = 101 ^ 011 ^ 001</p>
<p>hash(101011001) = 101 ^ 110 ^ 001</p>
<h3 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a>伪随机数</h3><p>伪随机数发生器：rand(x+1) = [a * rand(x)] % M   //M是素数</p>
<p>rand(key) = [rand(0) * (a ** key)] % M</p>
<p>伪随机数发生器依赖于各个平台的具体实现，可移植性较差，慎用！！！</p>
<h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">hashcode</span><span class="params">(<span class="keyword">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        h = (h &lt;&lt; <span class="number">5</span>) | (h &gt;&gt; <span class="number">27</span>);</span><br><span class="line">        h += (<span class="keyword">int</span>)s[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">size_t</span>) h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冲突排解"><a href="#冲突排解" class="headerlink" title="冲突排解"></a>冲突排解</h2>
	
	</div>
  <a type="button" href="/2021/07/06/散列/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/07/05/CPU分页模式/" >分页模式开启</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-07-05  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/07/05/CPU分页模式/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h2><p>设置 CPU 的 CR0 的 PE 位为 1，这样就开启了 MMU。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov eax, PAGE_TLB_BADR ;页表物理地址</span><br><span class="line">mov cr3, eax</span><br><span class="line">;开启 保护模式和分页模式</span><br><span class="line">mov eax, cr0</span><br><span class="line">bts eax, 0 ;CR0.PE =1</span><br><span class="line">bts eax, 31 ;CR0.P = 1</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2021/07/05/CPU分页模式/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/07/05/CPU缓存/" >CPU缓存</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-07-05  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		

	

	</div>
  <a type="button" href="/2021/07/05/CPU缓存/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h2><p>MESI 协议定义了 4 种基本状态：M、E、S、I，即修改（Modified）、独占（Exclusive）、共享（Shared）和无效（Invalid）。</p>
<p>1.M 修改（Modified）：当前 Cache 的内容有效，数据已经被修改而且与内存中的数据不一致，数据只在当前 Cache 里存在。</p>
<p>2.E 独占（Exclusive）：当前 Cache 中的内容有效，数据与内存中的数据一致，数据只在当前 Cache 里存在。</p>
<p>3.S 共享（Shared）：当前 Cache 中的内容有效，Cache 中的数据与内存中的数据一致，数据在多个 CPU 核心中的 Cache 里面存在。</p>
<p>4.无效（Invalid）：当前 Cache 无效。</p>
<p>Cache 硬件，它会监控所有 CPU 上 Cache 的操作，根据相应的操作使得 Cache 里的数据行在上面这些状态之间切换。Cache 硬件通过这些状态的变化，就能安全地控制各 Cache 间、各 Cache 与内存之间的数据一致性了。</p>
<h2 id="开启-Cache"><a href="#开启-Cache" class="headerlink" title="开启 Cache"></a>开启 Cache</h2><p>在 x86 CPU 上开启 Cache 非常简单，只需要将 CR0 寄存器中 CD、NW 位同时清 0 即可。CD=1 时表示 Cache 关闭，NW=1 时 CPU 不维护内存数据一致性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax, cr0</span><br><span class="line">;开启 CACHE    </span><br><span class="line">btr eax,29 ;CR0.NW=0</span><br><span class="line">btr eax,30  ;CR0.CD=0</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure>

<h2 id="获取内存视图"><a href="#获取内存视图" class="headerlink" title="获取内存视图"></a>获取内存视图</h2><p>给出一个物理地址并不能准确地定位到内存空间，内存空间只是映射物理地址空间中的一个子集，物理地址空间中可能有空洞，有 ROM，有内存，有显存，有 I/O 寄存器，所以获取内存有多大没用，关键是要获取哪些物理地址空间是可以读写的内存。</p>
<p>物理地址空间是由北桥芯片控制管理的，那我们是不是要找北桥要内存的地址空间呢？当然不是，在 x86 平台上还有更方便简单的办法，那就是 BIOS 提供的实模式下中断服务，就是 int 指令后面跟着一个常数的形式。由于 PC 机上电后由 BIOS 执行硬件初始化，中断向量表是 BIOS 设置的，所以执行中断自然执行 BIOS 服务。这个中断服务是 int 15h，但是它需要一些参数，就是在执行 int 15h 之前，对特定寄存器设置一些值，代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_getmemmap:  </span><br><span class="line">    xor ebx,ebx ;ebx设为0  </span><br><span class="line">    mov edi,E80MAP_ADR ;edi设为存放输出结果的1MB内的物理内存</span><br><span class="line">loop:  </span><br><span class="line">    mov eax,0e820h ;eax必须为0e820h  </span><br><span class="line">    mov ecx,20 ;输出结果数据项的大小为20字节：8字节内存基地址，8字节内存长度，4字节内存类型  </span><br><span class="line">    mov edx,0534d4150h ;edx必须为0534d4150h  </span><br><span class="line">    int 15h ;执行中断  </span><br><span class="line">    jc error ;如果flags寄存器的C位置1，则表示出错  </span><br><span class="line">    add edi,20;更新下一次输出结果的地址  </span><br><span class="line">    cmp ebx,0 ;如ebx为0，则表示循环迭代结束  </span><br><span class="line">    jne loop  ;还有结果项，继续迭代    </span><br><span class="line">    ret</span><br><span class="line">error:;出错处理</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_USABLE 1 <span class="comment">//可用内存</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_RESERV 2 <span class="comment">//保留内存不可使用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_ACPIREC 3 <span class="comment">//ACPI表相关的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_ACPINVS 4 <span class="comment">//ACPI NVS空间</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_AREACON 5 <span class="comment">//包含坏内存</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_e820</span>&#123;</span>    </span><br><span class="line">    <span class="keyword">u64_t</span> saddr;    <span class="comment">/* 内存开始地址 */</span>    </span><br><span class="line">    <span class="keyword">u64_t</span> lsize;    <span class="comment">/* 内存大小 */</span>    </span><br><span class="line">    <span class="keyword">u32_t</span> type;    <span class="comment">/* 内存类型 */</span></span><br><span class="line">&#125;<span class="keyword">e820map_t</span>;</span><br></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2021/07/05/CPU缓存/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/07/04/CPU工作模式/" >CPU实模式和保护模式</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-07-04  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	

		
        
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
            
            
		
		
            
            <p class="post">&lt;h2 id=&#34;实模式&#34;&gt;&lt;a href=&#34;#实模式&#34; class=&#34;headerlink&#34; title=&#34;实模式&#34;&gt;&lt;/a&gt;实模式&lt;/h2&gt;&lt;p&gt;实模式又称实地址模式，对内存不加以任何的限制。&lt;/p&gt;
&lt;h3 id=&#34;实模式的寄存器&#34;&gt;&lt;a href=&#34;#实模式的寄存器&#34; class=&#34;headerlink&#34; title=&#34;实模式的寄存器&#34;&gt;&lt;/a&gt;实模式的寄存器&lt;/h3&gt;&lt;p&gt;x86CPU在实模式下的寄存器都是16位的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;寄存器&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;AX、BX、CX、DX、DI、SI、BP&lt;/td&gt;
&lt;td&gt;通用寄存器，里面可以存放数据、地址、参与运算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IP&lt;/td&gt;
&lt;td&gt;程序指针寄存器，始终指向下一条指令的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SP&lt;/td&gt;
&lt;td&gt;栈指针寄存器，始终指向当前栈顶&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CS、DS、ES、SS&lt;/td&gt;
&lt;td&gt;段寄存器，里面存放一个内存段的基地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FLAGS&lt;/td&gt;
&lt;td&gt;标志寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;实模式下访问内存&#34;&gt;&lt;a href=&#34;#实模式下访问内存&#34; class=&#34;headerlink&#34; title=&#34;实模式下访问内存&#34;&gt;&lt;/a&gt;实模式下访问内存&lt;/h3&gt;&lt;p&gt;实模式下所有的内存地址都是由段寄存器左移 4 位，再加上一个通用寄存器中的值或者常数形成地址，然后由这个地址去访问内存。&lt;/p&gt;
&lt;h3 id=&#34;实模式中断&#34;&gt;&lt;a href=&#34;#实模式中断&#34; class=&#34;headerlink&#34; title=&#34;实模式中断&#34;&gt;&lt;/a&gt;实模式中断&lt;/h3&gt;&lt;p&gt;中断即中止执行当前程序，转而跳转到另一个特定的地址上，去运行特定的代码。在实模式下它的实现过程是先保存 CS 和 IP 寄存器，然后装载新的 CS 和 IP 寄存器。&lt;/p&gt;
&lt;p&gt;通过IDTR查找中断向量表，根据中断号索引中断处理的地址。&lt;/p&gt;
&lt;h2 id=&#34;保护模式&#34;&gt;&lt;a href=&#34;#保护模式&#34; class=&#34;headerlink&#34; title=&#34;保护模式&#34;&gt;&lt;/a&gt;保护模式&lt;/h2&gt;&lt;h3 id=&#34;保护模式寄存器&#34;&gt;&lt;a href=&#34;#保护模式寄存器&#34; class=&#34;headerlink&#34; title=&#34;保护模式寄存器&#34;&gt;&lt;/a&gt;保护模式寄存器&lt;/h3&gt;&lt;p&gt;保护模式相比于实模式，增加了一些控制寄存器和段寄存器，扩展通用寄存器的位宽，所有的通用寄存器都是 32 位的，还可以单独使用低 16 位，这个低 16 位又可以拆分成两个 8 位寄存器，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;寄存器&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;EAX、EBX、ECX、EDX、EDI、ESI、EBP&lt;/td&gt;
&lt;td&gt;通用寄存器，里面可以存放数据、地址、参与运算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EIP&lt;/td&gt;
&lt;td&gt;程序指针寄存器，始终指向下一条指令的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
<p>
		

	

	</div>
  <a type="button" href="/2021/07/04/CPU工作模式/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h2><p>实模式又称实地址模式，对内存不加以任何的限制。</p>
<h3 id="实模式的寄存器"><a href="#实模式的寄存器" class="headerlink" title="实模式的寄存器"></a>实模式的寄存器</h3><p>x86CPU在实模式下的寄存器都是16位的。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AX、BX、CX、DX、DI、SI、BP</td>
<td>通用寄存器，里面可以存放数据、地址、参与运算</td>
</tr>
<tr>
<td>IP</td>
<td>程序指针寄存器，始终指向下一条指令的地址</td>
</tr>
<tr>
<td>SP</td>
<td>栈指针寄存器，始终指向当前栈顶</td>
</tr>
<tr>
<td>CS、DS、ES、SS</td>
<td>段寄存器，里面存放一个内存段的基地址</td>
</tr>
<tr>
<td>FLAGS</td>
<td>标志寄存器</td>
</tr>
</tbody></table>
<h3 id="实模式下访问内存"><a href="#实模式下访问内存" class="headerlink" title="实模式下访问内存"></a>实模式下访问内存</h3><p>实模式下所有的内存地址都是由段寄存器左移 4 位，再加上一个通用寄存器中的值或者常数形成地址，然后由这个地址去访问内存。</p>
<h3 id="实模式中断"><a href="#实模式中断" class="headerlink" title="实模式中断"></a>实模式中断</h3><p>中断即中止执行当前程序，转而跳转到另一个特定的地址上，去运行特定的代码。在实模式下它的实现过程是先保存 CS 和 IP 寄存器，然后装载新的 CS 和 IP 寄存器。</p>
<p>通过IDTR查找中断向量表，根据中断号索引中断处理的地址。</p>
<h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><h3 id="保护模式寄存器"><a href="#保护模式寄存器" class="headerlink" title="保护模式寄存器"></a>保护模式寄存器</h3><p>保护模式相比于实模式，增加了一些控制寄存器和段寄存器，扩展通用寄存器的位宽，所有的通用寄存器都是 32 位的，还可以单独使用低 16 位，这个低 16 位又可以拆分成两个 8 位寄存器，</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>EAX、EBX、ECX、EDX、EDI、ESI、EBP</td>
<td>通用寄存器，里面可以存放数据、地址、参与运算</td>
</tr>
<tr>
<td>EIP</td>
<td>程序指针寄存器，始终指向下一条指令的地址</td>
</tr>
<tr>
<td>ESP</td>
<td>栈指针寄存器，始终指向当前栈顶</td>
</tr>
<tr>
<td>CS、DS、ES、SS、FS、GS</td>
<td>段寄存器，里面存放一个内存段的基地址</td>
</tr>
<tr>
<td>EFLAGS</td>
<td>标志寄存器</td>
</tr>
<tr>
<td>CRO、CR1、CR2、CR3</td>
<td>CPU控制寄存器，控制CPU的功能特性</td>
</tr>
</tbody></table>
<h3 id="保护模式特权级"><a href="#保护模式特权级" class="headerlink" title="保护模式特权级"></a>保护模式特权级</h3><p>特权级分为4级R0～R3</p>
<h3 id="切换到保护模式"><a href="#切换到保护模式" class="headerlink" title="切换到保护模式"></a>切换到保护模式</h3><p>段描述符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq 0</span><br><span class="line">;第一个段描述符CPU硬件规定必须为0</span><br><span class="line">kcode_dsc: dq 0x00cf9e000000ffff</span><br><span class="line">;段基地址=0，段长度=0xfffff</span><br><span class="line">;G=1,D/B=1,L=0,AVL=0 </span><br><span class="line">;P=1,DPL=0,S=1</span><br><span class="line">;T=1,C=1,R=1,A=0</span><br><span class="line">kdata_dsc: dq 0x00cf92000000ffff</span><br><span class="line">;段基地址=0，段长度=0xfffff</span><br><span class="line">;G=1,D/B=1,L=0,AVL=0 </span><br><span class="line">;P=1,DPL=0,S=1</span><br><span class="line">;T=0,C=0,R=1,A=0</span><br><span class="line">GDT_END:</span><br><span class="line"></span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLEN  dw GDT_END-GDT_START-1</span><br><span class="line">GDTBASE  dd GDT_START</span><br></pre></td></tr></table></figure>

<p>1、准备全局段描述符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GDT_START:knull_dsc: dq 0kcode_dsc: dq 0x00cf9e000000ffffkdata_dsc: dq 0x00cf92000000ffffGDT_END:GDT_PTR:GDTLEN  dw GDT_END-GDT_START-1GDTBASE  dd GDT_START</span><br></pre></td></tr></table></figure>

<p>2、加载gdtr寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt [GDT_PTR]</span><br></pre></td></tr></table></figure>

<p>3、设置 CR0 寄存器，开启保护模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;开启 PE</span><br><span class="line">mov eax, cr0</span><br><span class="line">bts eax, 0                      ; CR0.PE =1</span><br><span class="line">mov cr0, eax         </span><br></pre></td></tr></table></figure>

<p>4、进行长跳转，加载 CS 段寄存器，即段选择子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp dword 0x8 :_32bits_mode ;_32bits_mode为32位代码标号即段偏移</span><br></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2021/07/04/CPU工作模式/#more" class="btn btn-default more">Read More</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">

   
    
     <a href="/" type="button" class="btn btn-default"><i class="fa fa-arrow-circle-o-left"></i> Prev</a>
      

        <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
 
       <a href="/page/3/" type="button" class="btn btn-default ">Next<i class="fa fa-arrow-circle-o-right"></i></a>     
        

  
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/windows内核/">windows内核<span>5</span></a></li>
		
			<li><a href="/tags/恶意代码分析/">恶意代码分析<span>1</span></a></li>
		
			<li><a href="/tags/算法与数据结构/">算法与数据结构<span>3</span></a></li>
		
			<li><a href="/tags/符号执行/">符号执行<span>1</span></a></li>
		
			<li><a href="/tags/python/">python<span>2</span></a></li>
		
			<li><a href="/tags/CPU/">CPU<span>3</span></a></li>
		
			<li><a href="/tags/Android/">Android<span>1</span></a></li>
		
			<li><a href="/tags/软件调试/">软件调试<span>1</span></a></li>
		
			<li><a href="/tags/CTF-Writeup/">CTF,Writeup<span>2</span></a></li>
		
			<li><a href="/tags/漏洞研究/">漏洞研究<span>1</span></a></li>
		
			<li><a href="/tags/unix/">unix<span>2</span></a></li>
		
			<li><a href="/tags/CTF/">CTF<span>1</span></a></li>
		
			<li><a href="/tags/漏洞分析/">漏洞分析<span>6</span></a></li>
		
			<li><a href="/tags/fuzzing/">fuzzing<span>1</span></a></li>
		
			<li><a href="/tags/正则表达式/">正则表达式<span>1</span></a></li>
		
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2021/09/30/一个加密木马的分析/" ><i class="fa fa-file-o"></i>一个加密木马的分析</a>
      </li>
    
      <li>
        <a href="/2021/09/24/Windows系统调用/" ><i class="fa fa-file-o"></i>Windows系统调用</a>
      </li>
    
      <li>
        <a href="/2021/09/17/Windbg用法/" ><i class="fa fa-file-o"></i>Windbg用法</a>
      </li>
    
      <li>
        <a href="/2021/09/09/遇到hexo莫名其妙的bug/" ><i class="fa fa-file-o"></i>遇到hexo莫名其妙的bug</a>
      </li>
    
      <li>
        <a href="/2021/09/07/CVE-2021-3156分析/" ><i class="fa fa-file-o"></i>CVE-2021-3156分析</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/p1ain0" title="My Github account." target="_blank"]);">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2021 P1AIN0&#39;S BLOG
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
